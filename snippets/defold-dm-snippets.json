{"dmScript::LuaCallbackInfo": [{"body": "dmScript::LuaCallbackInfo", "prefix": "dmScript::LuaCallbackInfo", "description": "callback info struct"}], "SetReceiveTimeout(socket, timeout)": [{"body": "SetReceiveTimeout(${1:socket}, ${2:timeout})", "prefix": "SetReceiveTimeout(socket, timeout)", "description": "Set socket receive timeout"}], "dmBuffer::StreamDeclaration": [{"body": "dmBuffer::StreamDeclaration", "prefix": "dmBuffer::StreamDeclaration", "description": "StreamDeclaration struct"}], "dmGraphics::GetNativeAndroidApp": [{"body": "dmGraphics::GetNativeAndroidApp()", "prefix": "dmGraphics::GetNativeAndroidApp", "description": "get Android app object"}], "dmScript::PushMatrix4(L, matrix)": [{"body": "dmScript::PushMatrix4(${1:L}, ${2:matrix})", "prefix": "dmScript::PushMatrix4(L, matrix)", "description": "push a Vectormath::Aos::Matrix4 onto the Lua stack"}], "SendAttribute(request, key, value)": [{"body": "SendAttribute(${1:request}, ${2:key}, ${3:value})", "prefix": "SendAttribute(request, key, value)", "description": "Sends a header attribute"}], "dmScript::Ref(L, table)": [{"body": "dmScript::Ref(${1:L}, ${2:table})", "prefix": "dmScript::Ref(L, table)", "description": "wrapper for luaL_ref."}], "HConnection": [{"body": "HConnection", "prefix": "HConnection", "description": "Connection handle"}], "dmURI::Result": [{"body": "dmURI::Result()", "prefix": "dmURI::Result", "description": "URI parsing result"}], "Select([type:class, [type:class, [type:class)": [{"body": "Select(${1:[type:class}, ${2:[type:class}, ${3:[type:class})", "prefix": "Select([type:class, [type:class, [type:class)", "description": "Select one of two values"}], "Node": [{"body": "Node", "prefix": "Node", "description": "Json node representation."}], "SelectorClear(selector, selector_kind, socket)": [{"body": "SelectorClear(${1:selector}, ${2:selector_kind}, ${3:socket})", "prefix": "SelectorClear(selector, selector_kind, socket)", "description": "Clear selector for socket. Similar to FD_CLR"}], "DM_PLATFORM_WINDOWS": [{"body": "DM_PLATFORM_WINDOWS", "prefix": "DM_PLATFORM_WINDOWS", "description": "Set if the platform is Windows  (on both x86 and x86_64)"}], "SetSize(size)": [{"body": "SetSize(${1:size})", "prefix": "SetSize(size)", "description": "array set size"}], "dmTime::GetTime": [{"body": "dmTime::GetTime()", "prefix": "dmTime::GetTime", "description": "get current time in microseconds"}], "DM_PLATFORM_IOS": [{"body": "DM_PLATFORM_IOS", "prefix": "DM_PLATFORM_IOS", "description": "Set if the platform is iPhoneOS "}], "dmMutex::TryLock(mutex)": [{"body": "dmMutex::TryLock(${1:mutex})", "prefix": "dmMutex::TryLock(mutex)", "description": "non-blocking lock of Mutex."}], "Selector": [{"body": "Selector", "prefix": "Selector", "description": "Selector"}], "dmScript::Unref(L, table, reference)": [{"body": "dmScript::Unref(${1:L}, ${2:table}, ${3:reference})", "prefix": "dmScript::Unref(L, table, reference)", "description": "wrapper for luaL_unref."}], "Remaining": [{"body": "Remaining()", "prefix": "Remaining", "description": "remaining size of array"}], "GetKeyboard(context, index)": [{"body": "GetKeyboard(${1:context}, ${2:index})", "prefix": "GetKeyboard(context, index)", "description": "gets a keyboard handle"}], "GetMousePacket(mouse, out_packet)": [{"body": "GetMousePacket(${1:mouse}, ${2:out_packet})", "prefix": "GetMousePacket(mouse, out_packet)", "description": "Obtain a mouse packet reflecting the current input..."}], "dmHashString64(string)": [{"body": "dmHashString64(${1:string})", "prefix": "dmHashString64(string)", "description": "calculate 64-bit hash value from string"}], "Full": [{"body": "Full()", "prefix": "Full", "description": "array full"}], "Address": [{"body": "Address", "prefix": "Address", "description": "network address"}], "SceneNodeProperty": [{"body": "SceneNodeProperty", "prefix": "SceneNodeProperty", "description": "scene traversal node property"}], "dmConnectionPool::Shutdown(pool, how)": [{"body": "dmConnectionPool::Shutdown(${1:pool}, ${2:how})", "prefix": "dmConnectionPool::Shutdown(pool, how)", "description": "Shuts down all open sockets in the pool and block ..."}], "dmScript::IsVector3(L, index)": [{"body": "dmScript::IsVector3(${1:L}, ${2:index})", "prefix": "dmScript::IsVector3(L, index)", "description": "Check if the value at #index is a Vectormath::Aos:..."}], "dmHID::HMouse": [{"body": "dmHID::HMouse", "prefix": "dmHID::HMouse", "description": "mouse context handle"}], "dmThread::SetThreadName(thread, name)": [{"body": "dmThread::SetThreadName(${1:thread}, ${2:name})", "prefix": "dmThread::SetThreadName(thread, name)", "description": "sets the current thread name"}], "dmLogInfo(format, args)": [{"body": "dmLogInfo(${1:format}, ${2:args})", "prefix": "dmLogInfo(format, args)", "description": "log with \"info\" severity"}], "dmStrTok(string, delim, lasts)": [{"body": "dmStrTok(${1:string}, ${2:delim}, ${3:lasts})", "prefix": "dmStrTok(string, delim, lasts)", "description": "Tokenize strings."}], "dmSnPrintf(buffer, count, format)": [{"body": "dmSnPrintf(${1:buffer}, ${2:count}, ${3:format})", "prefix": "dmSnPrintf(buffer, count, format)", "description": "Size-bounded string formating."}], "dmHID::INVALID_TOUCHDEVICE_HANDLE [type: dmHID::HTouchDevice]": [{"body": "dmHID::INVALID_TOUCHDEVICE_HANDLE [type: dmHID::HTouchDevice]()", "prefix": "dmHID::INVALID_TOUCHDEVICE_HANDLE [type: dmHID::HTouchDevice]", "description": "invalid touch devicehandle"}], "dmThread::FreeTls(key)": [{"body": "dmThread::FreeTls(${1:key})", "prefix": "dmThread::FreeTls(key)", "description": "free thread local storage key"}], "DM_ALIGNED(a)": [{"body": "DM_ALIGNED", "prefix": "DM_ALIGNED(a)", "description": "data structure alignment macro"}], "HInstance": [{"body": "HInstance", "prefix": "HInstance", "description": "Gameobject instance handle"}], "SetScale(instance, scale)": [{"body": "SetScale(${1:instance}, ${2:scale})", "prefix": "SetScale(instance, scale)", "description": "set uniform scale"}, {"body": "SetScale(${1:instance}, ${2:scale})", "prefix": "SetScale(instance, scale)", "description": "set scale"}], "GetFD(socket)": [{"body": "GetFD(${1:socket})", "prefix": "GetFD(socket)", "description": "get underlying file descriptor"}], "dmHID::MAX_MOUSE_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_MOUSE_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_MOUSE_COUNT [type: uint32_t]", "description": "Maximum number of mice supported"}], "HScript": [{"body": "HScript", "prefix": "HScript", "description": "Script handle"}], "SetSendTimeout(socket, timeout)": [{"body": "SetSendTimeout(${1:socket}, ${2:timeout})", "prefix": "SetSendTimeout(socket, timeout)", "description": "Set socket send timeout"}], "dmMutex::New": [{"body": "dmMutex::New()", "prefix": "dmMutex::New", "description": "create Mutex"}], "dmThread::Join(thread)": [{"body": "dmThread::Join(${1:thread})", "prefix": "dmThread::Join(thread)", "description": "join thread"}, {"body": "dmThread::Join(${1:thread})", "prefix": "dmThread::Join(thread)", "description": "detach thread"}], "dmGraphics::GetNativeWindowsHGLRC": [{"body": "dmGraphics::GetNativeWindowsHGLRC()", "prefix": "dmGraphics::GetNativeWindowsHGLRC", "description": "get Win32 HGLRC"}], "dmHID::MAX_GAMEPAD_AXIS_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_GAMEPAD_AXIS_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_GAMEPAD_AXIS_COUNT [type: uint32_t]", "description": "Maximum number of gamepad axis supported"}], "Key": [{"body": "Key", "prefix": "Key", "description": "keyboard key enumeration"}], "Front": [{"body": "Front()", "prefix": "Front", "description": "array front"}, {"body": "Front()", "prefix": "Front", "description": "array front (const)"}], "SceneNodePropertyIterator": [{"body": "SceneNodePropertyIterator", "prefix": "SceneNodePropertyIterator", "description": "scene traversal node property"}], "ParseResult": [{"body": "ParseResult", "prefix": "ParseResult", "description": "header parse result enumeration"}], "dmCrypt::Base64Encode(src, src_len, dst, dst_len[in,out])": [{"body": "dmCrypt::Base64Encode(${1:src}, ${2:src_len}, ${3:dst}, ${4:dst_len[in,out]})", "prefix": "dmCrypt::Base64Encode(src, src_len, dst, dst_len[in,out])", "description": "Base64 encode a buffer"}], "dmScript::ToQuat(L, index)": [{"body": "dmScript::ToQuat(${1:L}, ${2:index})", "prefix": "dmScript::ToQuat(L, index)", "description": "get the value at index as a Vectormath::Aos::Quat*"}], "dmHID::INVALID_KEYBOARD_HANDLE [type: dmHID::HKeyboard]": [{"body": "dmHID::INVALID_KEYBOARD_HANDLE [type: dmHID::HKeyboard]()", "prefix": "dmHID::INVALID_KEYBOARD_HANDLE [type: dmHID::HKeyboard]", "description": "invalid keyboard handle"}], "HProperties": [{"body": "HProperties", "prefix": "HProperties", "description": "Gameobject properties handle"}], "dmStrlCpy(dst, src, size)": [{"body": "dmStrlCpy(${1:dst}, ${2:src}, ${3:size})", "prefix": "dmStrlCpy(dst, src, size)", "description": "Size-bounded string copying."}], "dmConditionVariable::Broadcast(condition)": [{"body": "dmConditionVariable::Broadcast(${1:condition})", "prefix": "dmConditionVariable::Broadcast(condition)", "description": "broadcast condition variable"}], "dmLogUserDebug(format, args)": [{"body": "dmLogUserDebug(${1:format}, ${2:args})", "prefix": "dmLogUserDebug(format, args)", "description": "log with \"user\" severity"}], "AddHandler(server, prefix, handler_params)": [{"body": "AddHandler(${1:server}, ${2:prefix}, ${3:handler_params})", "prefix": "AddHandler(server, prefix, handler_params)", "description": "Add a new handler"}], "dmScript::SetupCallback(cbk)": [{"body": "dmScript::SetupCallback(${1:cbk})", "prefix": "dmScript::SetupCallback(cbk)", "description": "Setups up the Lua callback prior to a call to dmScript::PCall()"}], "SOCKET_TIMEOUT": [{"body": "SOCKET_TIMEOUT", "prefix": "SOCKET_TIMEOUT", "description": "Socket default timeout value"}], "dmHashTable": [{"body": "dmHashTable()", "prefix": "dmHashTable", "description": "hashtable"}], "dmScript::IsVector4(L, index)": [{"body": "dmScript::IsVector4(${1:L}, ${2:index})", "prefix": "dmScript::IsVector4(L, index)", "description": "Check if the value at #index is a Vectormath::Aos:..."}], "Protocol": [{"body": "Protocol", "prefix": "Protocol", "description": "network protocol"}], "Send(socket, buffer, length, sent_bytes[out])": [{"body": "Send(${1:socket}, ${2:buffer}, ${3:length}, ${4:sent_bytes[out]})", "prefix": "Send(socket, buffer, length, sent_bytes[out])", "description": "Send a message on a socket"}], "SetBroadcast(socket, broadcast)": [{"body": "SetBroadcast(${1:socket}, ${2:broadcast})", "prefix": "SetBroadcast(socket, broadcast)", "description": "Set broadcast address option on socket. Socket opt..."}], "GetHIDContext(app_params)": [{"body": "GetHIDContext(${1:app_params})", "prefix": "GetHIDContext(app_params)", "description": "get the hid context"}], "DM_PLATFORM_LINUX": [{"body": "DM_PLATFORM_LINUX", "prefix": "DM_PLATFORM_LINUX", "description": "Set if the platform is Linux "}], "dmScript::CheckQuat(L, index)": [{"body": "dmScript::CheckQuat(${1:L}, ${2:index})", "prefix": "dmScript::CheckQuat(L, index)", "description": "check if the value is a Vectormath::Aos::Vector3"}], "OnActivityResult(env, activity, request_code, result_code, result)": [{"body": "OnActivityResult", "prefix": "OnActivityResult(env, activity, request_code, result_code, result)", "description": "OnActivityResult callback typedef"}], "GetScale(instance)": [{"body": "GetScale(${1:instance})", "prefix": "GetScale(instance)", "description": "get scale"}], "dmBuffer::Create(count, streams_decl, streams_decl_count, out_buffer)": [{"body": "dmBuffer::Create(${1:count}, ${2:streams_decl}, ${3:streams_decl_count}, ${4:out_buffer})", "prefix": "dmBuffer::Create(count, streams_decl, streams_decl_count, out_buffer)", "description": "create Buffer"}], "Size": [{"body": "Size()", "prefix": "Size", "description": "size of array"}], "dmConnectionPool::Dial(pool, host, port, ssl, timeout, cancelflag, connection, sock_res)": [{"body": "dmConnectionPool::Dial(${1:pool}, ${2:host}, ${3:port}, ${4:ssl}, ${5:timeout}, ${6:cancelflag}, ${7:connection}, ${8:sock_res})", "prefix": "dmConnectionPool::Dial(pool, host, port, ssl, timeout, cancelflag, connection, sock_res)", "description": "Connection to a host/port"}], "dmGraphics::GetNativeX11GLXContext": [{"body": "dmGraphics::GetNativeX11GLXContext()", "prefix": "dmGraphics::GetNativeX11GLXContext", "description": "get Linux X11GLXContext"}], "dmScript::ToVector4(L, index)": [{"body": "dmScript::ToVector4(${1:L}, ${2:index})", "prefix": "dmScript::ToVector4(L, index)", "description": "get the value at index as a Vectormath::Aos::Vector4*"}], "dmCrypt::Base64Decode(src, src_len, dst, dst_len[in,out])": [{"body": "dmCrypt::Base64Decode(${1:src}, ${2:src_len}, ${3:dst}, ${4:dst_len[in,out]})", "prefix": "dmCrypt::Base64Decode(src, src_len, dst, dst_len[in,out])", "description": "Base64 decode a buffer"}], "dmArray": [{"body": "dmArray", "prefix": "dmArray", "description": "Templatized array with bounds checking."}, {"body": "dmArray()", "prefix": "dmArray", "description": "constructor. empty auto-allocated memory"}], "dmConnectionPool::GetSSLSocket(pool, connection)": [{"body": "dmConnectionPool::GetSSLSocket(${1:pool}, ${2:connection})", "prefix": "dmConnectionPool::GetSSLSocket(pool, connection)", "description": "Get secure socket."}], "GetWorldScale(instance)": [{"body": "GetWorldScale(${1:instance})", "prefix": "GetWorldScale(instance)", "description": "get world scale"}], "dmTime::Sleep(useconds)": [{"body": "dmTime::Sleep(${1:useconds})", "prefix": "dmTime::Sleep(useconds)", "description": "sleep thread with low precision (~10 milliseconds)."}], "Min([type:class, [type:class)": [{"body": "Min(${1:[type:class}, ${2:[type:class})", "prefix": "Min([type:class, [type:class)", "description": "Min function"}], "End": [{"body": "End()", "prefix": "End", "description": "array end"}], "SetStatusCode(request, status_code)": [{"body": "SetStatusCode(${1:request}, ${2:status_code})", "prefix": "SetStatusCode(request, status_code)", "description": "Set response status code."}], "TraverseIterateProperties(node)": [{"body": "TraverseIterateProperties(${1:node})", "prefix": "TraverseIterateProperties(node)", "description": "Create a scene node traversal property iterator"}], "dmConditionVariable::Wait(condition, mutex)": [{"body": "dmConditionVariable::Wait(${1:condition}, ${2:mutex})", "prefix": "dmConditionVariable::Wait(condition, mutex)", "description": "wait for condition variable"}], "dmThread::GetTlsValue(key)": [{"body": "dmThread::GetTlsValue(${1:key})", "prefix": "dmThread::GetTlsValue(key)", "description": "get thread specific data"}], "dmBuffer::GetResultString(result)": [{"body": "dmBuffer::GetResultString(${1:result})", "prefix": "dmBuffer::GetResultString(result)", "description": "result to string"}], "GetMouse(context, index)": [{"body": "GetMouse(${1:context}, ${2:index})", "prefix": "GetMouse(context, index)", "description": "gets a mouse handle"}], "dmLogFatal(format, args)": [{"body": "dmLogFatal(${1:format}, ${2:args})", "prefix": "dmLogFatal(format, args)", "description": "log with \"fatal\" severity"}], "dmConnectionPool::Close(pool, connection)": [{"body": "dmConnectionPool::Close(${1:pool}, ${2:connection})", "prefix": "dmConnectionPool::Close(pool, connection)", "description": "Close connection. Use this function whenever an er..."}], "dmScript::PushVector3(L, v)": [{"body": "dmScript::PushVector3(${1:L}, ${2:v})", "prefix": "dmScript::PushVector3(L, v)", "description": "push a Vectormath::Aos::Vector3 onto the Lua stack"}], "dmBuffer::GetContentVersion(type, version)": [{"body": "dmBuffer::GetContentVersion(${1:type}, ${2:version})", "prefix": "dmBuffer::GetContentVersion(type, version)", "description": "Gets the current update number"}], "dmConnectionPool::New(params, pool)": [{"body": "dmConnectionPool::New(${1:params}, ${2:pool})", "prefix": "dmConnectionPool::New(params, pool)", "description": "Create a new connection pool"}], "dmMutex::Unlock(mutex)": [{"body": "dmMutex::Unlock(${1:mutex})", "prefix": "dmMutex::Unlock(mutex)", "description": "unlock Mutex."}], "dmHID::HKeyboard": [{"body": "dmHID::HKeyboard", "prefix": "dmHID::HKeyboard", "description": "keyboard context handle"}], "dmConfigFile::GetString(config, key, default_value)": [{"body": "dmConfigFile::GetString(${1:config}, ${2:key}, ${3:default_value})", "prefix": "dmConfigFile::GetString(config, key, default_value)", "description": "get config value as string"}], "KeyboardPacket": [{"body": "KeyboardPacket", "prefix": "KeyboardPacket", "description": "Contains the current state of a keyboard"}], "Type": [{"body": "Type", "prefix": "Type", "description": "socket type"}, {"body": "Type", "prefix": "Type", "description": "token type enumeration"}], "Receive(socket, buffer[out], length, received_bytes[out])": [{"body": "Receive(${1:socket}, ${2:buffer[out]}, ${3:length}, ${4:received_bytes[out]})", "prefix": "Receive(socket, buffer[out], length, received_bytes[out])", "description": "Receive data on a socket"}], "dmSSLSocket::INVALID_SOCKET_HANDLE": [{"body": "dmSSLSocket::INVALID_SOCKET_HANDLE", "prefix": "dmSSLSocket::INVALID_SOCKET_HANDLE", "description": "SSLSocket socket handle"}], "RegisterAndroidOnActivityResultListener([type:dmExtension::OnActivityResult])": [{"body": "RegisterAndroidOnActivityResultListener(${1:[type:dmExtension::OnActivityResult]})", "prefix": "RegisterAndroidOnActivityResultListener([type:dmExtension::OnActivityResult])", "description": "register Android activity result callback"}], "Document": [{"body": "Document", "prefix": "Document", "description": "Json document"}], "SetMouseWheel(mouse, value)": [{"body": "SetMouseWheel(${1:mouse}, ${2:value})", "prefix": "SetMouseWheel(mouse, value)", "description": "Sets the mouse wheel."}], "dmScript::ToVector3(L, index)": [{"body": "dmScript::ToVector3(${1:L}, ${2:index})", "prefix": "dmScript::ToVector3(L, index)", "description": "get the value at index as a Vectormath::Aos::Vector3*"}], "GetIdentifier(instance)": [{"body": "GetIdentifier(${1:instance})", "prefix": "GetIdentifier(instance)", "description": "Get instance identifier"}], "SetRotation(instance, position)": [{"body": "SetRotation(${1:instance}, ${2:position})", "prefix": "SetRotation(instance, position)", "description": "set rotation"}], "GetWorldMatrix(instance)": [{"body": "GetWorldMatrix(${1:instance})", "prefix": "GetWorldMatrix(instance)", "description": "get world matrix"}], "GetWebServer(app_params)": [{"body": "GetWebServer(${1:app_params})", "prefix": "GetWebServer(app_params)", "description": "get the web server handle"}], "DM_HEADLESS": [{"body": "DM_HEADLESS", "prefix": "DM_HEADLESS", "description": "define for headless builds"}], "DM_MUTEX_SCOPED_LOCK(mutex)": [{"body": "DM_MUTEX_SCOPED_LOCK", "prefix": "DM_MUTEX_SCOPED_LOCK(mutex)", "description": "macro for scope lifetime Mutex locking"}], "dmThread::GetCurrentThread": [{"body": "dmThread::GetCurrentThread()", "prefix": "dmThread::GetCurrentThread", "description": "gets the current thread"}], "SetNoDelay(socket, no_delay)": [{"body": "SetNoDelay(${1:socket}, ${2:no_delay})", "prefix": "SetNoDelay(socket, no_delay)", "description": "Set TCP_NODELAY on socket"}], "Abs([type:class)": [{"body": "Abs(${1:[type:class})", "prefix": "Abs([type:class)", "description": "Abs function"}], "RegisteriOSUIApplicationDelegate(delegate)": [{"body": "RegisteriOSUIApplicationDelegate(${1:delegate})", "prefix": "RegisteriOSUIApplicationDelegate(delegate)", "description": "Register application delegate"}], "Empty": [{"body": "Empty()", "prefix": "Empty", "description": "array empty"}], "dmHID::HGamepad": [{"body": "dmHID::HGamepad", "prefix": "dmHID::HGamepad", "description": "gamepad context handle"}], "dmBuffer::IsBufferValid(buffer)": [{"body": "dmBuffer::IsBufferValid(${1:buffer})", "prefix": "dmBuffer::IsBufferValid(buffer)", "description": "check buffer handle"}], "dmhash_t": [{"body": "dmhash_t", "prefix": "dmhash_t", "description": "dmhash_t type definition"}], "dmExtension::Event": [{"body": "dmExtension::Event", "prefix": "dmExtension::Event", "description": "event callback data"}], "Shutdown(socket, how)": [{"body": "Shutdown(${1:socket}, ${2:how})", "prefix": "Shutdown(socket, how)", "description": "close socket"}], "dmConditionVariable::New": [{"body": "dmConditionVariable::New()", "prefix": "dmConditionVariable::New", "description": "create condition variable"}], "dmConfigFile::HConfig": [{"body": "dmConfigFile::HConfig", "prefix": "dmConfigFile::HConfig", "description": "HConfig type definition"}], "dmConditionVariable::HConditionVariable": [{"body": "dmConditionVariable::HConditionVariable", "prefix": "dmConditionVariable::HConditionVariable", "description": "HConditionVariable type definition"}], "DLIB_LOG_DOMAIN": [{"body": "DLIB_LOG_DOMAIN", "prefix": "DLIB_LOG_DOMAIN", "description": "macro for debug category logging"}], "dmScript::TeardownCallback(cbk)": [{"body": "dmScript::TeardownCallback(${1:cbk})", "prefix": "dmScript::TeardownCallback(cbk)", "description": "Cleans up the stack after SetupCallback+PCall calls"}], "UnregisteriOSUIApplicationDelegate(delegate)": [{"body": "UnregisteriOSUIApplicationDelegate(${1:delegate})", "prefix": "UnregisteriOSUIApplicationDelegate(delegate)", "description": "Unregister an application delegate"}], "Connect(socket, address, port)": [{"body": "Connect(${1:socket}, ${2:address}, ${3:port})", "prefix": "Connect(socket, address, port)", "description": "make a connection"}], "PropertyResult": [{"body": "PropertyResult", "prefix": "PropertyResult", "description": "property result"}], "dmBuffer::ValidateBuffer(buffer)": [{"body": "dmBuffer::ValidateBuffer(${1:buffer})", "prefix": "dmBuffer::ValidateBuffer(buffer)", "description": "validate buffer."}], "GetHostByName(name, address, timeout, cancelflag, ipv4, ipv6)": [{"body": "GetHostByName(${1:name}, ${2:address}, ${3:timeout}, ${4:cancelflag}, ${5:ipv4}, ${6:ipv6})", "prefix": "GetHostByName(name, address, timeout, cancelflag, ipv4, ipv6)", "description": "get host by name with timeout and cancelability"}], "dmURI::Parse(uri, parts)": [{"body": "dmURI::Parse(${1:uri}, ${2:parts})", "prefix": "dmURI::Parse(uri, parts)", "description": "Parse URI and split in three parts. (scheme, locat..."}], "Pop": [{"body": "Pop()", "prefix": "Pop", "description": "array pop"}], "dmStrCaseCmp(s1, s2)": [{"body": "dmStrCaseCmp(${1:s1}, ${2:s2})", "prefix": "dmStrCaseCmp(s1, s2)", "description": "Case-insensitive string comparison"}], "dmBuffer::HBuffer": [{"body": "dmBuffer::HBuffer", "prefix": "dmBuffer::HBuffer", "description": "HBuffer type definition"}], "dmHID::INVALID_MOUSE_HANDLE [type: dmHID::HMouse]": [{"body": "dmHID::INVALID_MOUSE_HANDLE [type: dmHID::HMouse]()", "prefix": "dmHID::INVALID_MOUSE_HANDLE [type: dmHID::HMouse]", "description": "invalid mouse handle"}], "dmLogDebug(format, args)": [{"body": "dmLogDebug(${1:format}, ${2:args})", "prefix": "dmLogDebug(format, args)", "description": "log with \"debug\" severity"}], "DM_LUA_STACK_CHECK(L, diff)": [{"body": "DM_LUA_STACK_CHECK", "prefix": "DM_LUA_STACK_CHECK(L, diff)", "description": "helper macro to validate the Lua stack state before leaving a function."}], "dmArray(user_array, size, capacity)": [{"body": "dmArray(${1:user_array}, ${2:size}, ${3:capacity})", "prefix": "dmArray(user_array, size, capacity)", "description": "constructor. user-allocated memory"}], "TraverseGetRoot(regist, node)": [{"body": "TraverseGetRoot(${1:regist}, ${2:node})", "prefix": "TraverseGetRoot(regist, node)", "description": "Gets the top node of the whole game (the main coll..."}], "dmGraphics::GetNativeiOSEAGLContext": [{"body": "dmGraphics::GetNativeiOSEAGLContext()", "prefix": "dmGraphics::GetNativeiOSEAGLContext", "description": "get iOS EAGLContext"}], "dmGraphics::GetNativeAndroidJavaVM": [{"body": "dmGraphics::GetNativeAndroidJavaVM()", "prefix": "dmGraphics::GetNativeAndroidJavaVM", "description": "get Android native JavaVM"}], "dmHID::MAX_KEYBOARD_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_KEYBOARD_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_KEYBOARD_COUNT [type: uint32_t]", "description": "Maximum number of keyboards supported"}], "dmBuffer::GetStream(buffer, stream_name, stream, count, components, stride)": [{"body": "dmBuffer::GetStream(${1:buffer}, ${2:stream_name}, ${3:stream}, ${4:count}, ${5:components}, ${6:stride})", "prefix": "dmBuffer::GetStream(buffer, stream_name, stream, count, components, stride)", "description": "get stream from buffer."}], "dmMutex::Lock(mutex)": [{"body": "dmMutex::Lock(${1:mutex})", "prefix": "dmMutex::Lock(mutex)", "description": "lock Mutex."}], "Push(element)": [{"body": "Push(${1:element})", "prefix": "Push(element)", "description": "array push"}], "Domain": [{"body": "Domain", "prefix": "Domain", "description": "domain type"}], "dmSSLSocket::Delete(socket)": [{"body": "dmSSLSocket::Delete(${1:socket})", "prefix": "dmSSLSocket::Delete(socket)", "description": "delete a secure socket"}], "dmConnectionPool::GetSocket(pool, connection)": [{"body": "dmConnectionPool::GetSocket(${1:pool}, ${2:connection})", "prefix": "dmConnectionPool::GetSocket(pool, connection)", "description": "Get socket for connection"}], "Send(request, data, data_length)": [{"body": "Send(${1:request}, ${2:data}, ${3:data_length})", "prefix": "Send(request, data, data_length)", "description": "Send response data"}], "dmConnectionPool::Return(pool, connection)": [{"body": "dmConnectionPool::Return(${1:pool}, ${2:connection})", "prefix": "dmConnectionPool::Return(pool, connection)", "description": "Return connection to pool"}], "TraverseIterateChildren(node)": [{"body": "TraverseIterateChildren(${1:node})", "prefix": "TraverseIterateChildren(node)", "description": "Get a scene node iterator for the nodes' children"}], "dmBuffer::GetCount(buffer, count)": [{"body": "dmBuffer::GetCount(${1:buffer}, ${2:count})", "prefix": "dmBuffer::GetCount(buffer, count)", "description": "get buffer count."}], "SelectorKind": [{"body": "SelectorKind", "prefix": "SelectorKind", "description": "Selector kind"}], "GetWorldUniformScale(instance)": [{"body": "GetWorldUniformScale(${1:instance})", "prefix": "GetWorldUniformScale(instance)", "description": "get world uniform scale"}], "Delete(socket)": [{"body": "Delete(${1:socket})", "prefix": "Delete(socket)", "description": "delete a socket"}], "dmBuffer::GetSizeForValueType(type)": [{"body": "dmBuffer::GetSizeForValueType(${1:type})", "prefix": "dmBuffer::GetSizeForValueType(type)", "description": "get size of a value type"}], "dmCrypt::HashSha1(buf, buflen, digest)": [{"body": "dmCrypt::HashSha1(${1:buf}, ${2:buflen}, ${3:digest})", "prefix": "dmCrypt::HashSha1(buf, buflen, digest)", "description": "Hash buffer using SHA1"}], "Result": [{"body": "Result", "prefix": "Result", "description": "result codes"}, {"body": "Result", "prefix": "Result", "description": "socket result"}, {"body": "Result", "prefix": "Result", "description": "result enumeration"}, {"body": "Result", "prefix": "Result", "description": "Create result enum"}, {"body": "Result", "prefix": "Result", "description": "Update result enum"}, {"body": "Result", "prefix": "Result", "description": "result enumeration"}, {"body": "Result", "prefix": "Result", "description": "result enumeration"}], "dmSSLSocket::Send(socket, buffer, length, sent_bytes)": [{"body": "dmSSLSocket::Send(${1:socket}, ${2:buffer}, ${3:length}, ${4:sent_bytes})", "prefix": "dmSSLSocket::Send(socket, buffer, length, sent_bytes)", "description": "send a message on a secure socket"}], "SetMouseButton(mouse, button, value)": [{"body": "SetMouseButton(${1:mouse}, ${2:button}, ${3:value})", "prefix": "SetMouseButton(mouse, button, value)", "description": "Sets the state of a mouse button."}], "Free(document)": [{"body": "Free(${1:document})", "prefix": "Free(document)", "description": "deallocates json document"}], "dmScript::GetMainThread(L)": [{"body": "dmScript::GetMainThread(${1:L})", "prefix": "dmScript::GetMainThread(L)", "description": "Retrieve the main thread lua state from any lua st..."}], "dmHID::MAX_GAMEPAD_BUTTON_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_GAMEPAD_BUTTON_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_GAMEPAD_BUTTON_COUNT [type: uint32_t]", "description": "Maximum number of gamepad buttons supported"}], "dmURI::Encode(src, dst, dst_size, bytes_written[out])": [{"body": "dmURI::Encode(${1:src}, ${2:dst}, ${3:dst_size}, ${4:bytes_written[out]})", "prefix": "dmURI::Encode(src, dst, dst_size, bytes_written[out])", "description": "Performs URL encoding of the supplied buffer"}], "dmGraphics::GetNativeWindowsHWND": [{"body": "dmGraphics::GetNativeWindowsHWND()", "prefix": "dmGraphics::GetNativeWindowsHWND", "description": "get Win32 HWND"}], "dmGraphics::GetNativeiOSUIView": [{"body": "dmGraphics::GetNativeiOSUIView()", "prefix": "dmGraphics::GetNativeiOSUIView", "description": "get iOS UIView"}], "dmSSLSocket::New(socket, host, timeout, sslsocket)": [{"body": "dmSSLSocket::New(${1:socket}, ${2:host}, ${3:timeout}, ${4:sslsocket})", "prefix": "dmSSLSocket::New(socket, host, timeout, sslsocket)", "description": "create a secure socket"}], "dmExtension::EventID": [{"body": "dmExtension::EventID", "prefix": "dmExtension::EventID", "description": "event id enumeration"}], "Capacity": [{"body": "Capacity()", "prefix": "Capacity", "description": "capacity of array"}], "dmConnectionPool::Result": [{"body": "dmConnectionPool::Result", "prefix": "dmConnectionPool::Result", "description": "result enumeration"}], "DM_RELEASE": [{"body": "DM_RELEASE", "prefix": "DM_RELEASE", "description": "define for release builds"}], "dmHashTable32": [{"body": "dmHashTable32()", "prefix": "dmHashTable32", "description": "Specialized hash table with uint32_t as key..."}], "ResultToString(result)": [{"body": "ResultToString(${1:result})", "prefix": "ResultToString(result)", "description": "Convert result value to string"}], "dmExtension::Result": [{"body": "dmExtension::Result", "prefix": "dmExtension::Result", "description": "result enumeration"}], "dmThread::SetTlsValue(key, value)": [{"body": "dmThread::SetTlsValue(${1:key}, ${2:value})", "prefix": "dmThread::SetTlsValue(key, value)", "description": "set thread specific data"}], "dmLogWarning(format, args)": [{"body": "dmLogWarning(${1:format}, ${2:args})", "prefix": "dmLogWarning(format, args)", "description": "log with \"warning\" severity"}], "dmHID::HTouchDevice": [{"body": "dmHID::HTouchDevice", "prefix": "dmHID::HTouchDevice", "description": "touch device context handle"}], "SetQuickAck(socket, use_quick_ack)": [{"body": "SetQuickAck(${1:socket}, ${2:use_quick_ack})", "prefix": "SetQuickAck(socket, use_quick_ack)", "description": "Set TCP_QUICKACK on socket"}], "dmHashTable16": [{"body": "dmHashTable16()", "prefix": "dmHashTable16", "description": "Specialized hash table with uint16_t as key..."}], "dmURI::Parts": [{"body": "dmURI::Parts", "prefix": "dmURI::Parts", "description": "URI parsing result parts"}], "SetCapacity(capacity)": [{"body": "SetCapacity(${1:capacity})", "prefix": "SetCapacity(capacity)", "description": "array set capacity"}], "Swap(rhs)": [{"body": "Swap(${1:rhs})", "prefix": "Swap(rhs)", "description": "array swap"}], "GetPosition(instance)": [{"body": "GetPosition(${1:instance})", "prefix": "GetPosition(instance)", "description": "get position"}], "dmURI::Decode(src, dst)": [{"body": "dmURI::Decode(${1:src}, ${2:dst})", "prefix": "dmURI::Decode(src, dst)", "description": "Decodes an URL encoded buffer"}], "dmHID::MAX_TOUCH_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_TOUCH_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_TOUCH_COUNT [type: uint32_t]", "description": "Maximum number of simultaneous touches supported"}], "RemoveHandler(server, prefix)": [{"body": "RemoveHandler(${1:server}, ${2:prefix})", "prefix": "RemoveHandler(server, prefix)", "description": "Remove handle"}], "ParseHeader(header_str, user_data, end_of_receive, version_cbk, header_cbk, body_cbk)": [{"body": "ParseHeader(${1:header_str}, ${2:user_data}, ${3:end_of_receive}, ${4:version_cbk}, ${5:header_cbk}, ${6:body_cbk})", "prefix": "ParseHeader(header_str, user_data, end_of_receive, version_cbk, header_cbk, body_cbk)", "description": "parse the headers"}], "dmHID::HContext": [{"body": "dmHID::HContext", "prefix": "dmHID::HContext", "description": "HID context handle"}], "GetMouseButton(packet, button)": [{"body": "GetMouseButton(${1:packet}, ${2:button})", "prefix": "GetMouseButton(packet, button)", "description": "Convenience function to retrieve the state of a mo..."}], "dmGraphics::GetNativeOSXNSView": [{"body": "dmGraphics::GetNativeOSXNSView()", "prefix": "dmGraphics::GetNativeOSXNSView", "description": "get OSX NSView"}], "dmScript::CheckMatrix4(L, index)": [{"body": "dmScript::CheckMatrix4(${1:L}, ${2:index})", "prefix": "dmScript::CheckMatrix4(L, index)", "description": "check if the value is a Vectormath::Aos::Matrix4"}], "dmConfigFile::GetFloat(config, key, default_value)": [{"body": "dmConfigFile::GetFloat(${1:config}, ${2:key}, ${3:default_value})", "prefix": "dmConfigFile::GetFloat(config, key, default_value)", "description": "get config value as float"}], "dmBuffer::GetValueTypeString(result)": [{"body": "dmBuffer::GetValueTypeString(${1:result})", "prefix": "dmBuffer::GetValueTypeString(result)", "description": "value type to string"}], "HRegister": [{"body": "HRegister", "prefix": "HRegister", "description": "Collection register."}], "dmStrlCat(dst, src, size)": [{"body": "dmStrlCat(${1:dst}, ${2:src}, ${3:size})", "prefix": "dmStrlCat(dst, src, size)", "description": "Size-bounded string concatenation."}], "dmThread::AllocTls": [{"body": "dmThread::AllocTls()", "prefix": "dmThread::AllocTls", "description": "allocate thread local storage key"}], "dmBuffer::GetStreamType(buffer, stream_name, type, components)": [{"body": "dmBuffer::GetStreamType(${1:buffer}, ${2:stream_name}, ${3:type}, ${4:components})", "prefix": "dmBuffer::GetStreamType(buffer, stream_name, type, components)", "description": "get stream type and type count"}], "SetKey(keyboard, key, value)": [{"body": "SetKey(${1:keyboard}, ${2:key}, ${3:value})", "prefix": "SetKey(keyboard, key, value)", "description": "Sets the state of a key."}], "DM_ARRAY_SIZE(Array)": [{"body": "DM_ARRAY_SIZE", "prefix": "DM_ARRAY_SIZE(Array)", "description": "get number of elements in C array"}], "dmSSLSocket::Receive(socket, buffer, length, received_bytes)": [{"body": "dmSSLSocket::Receive(${1:socket}, ${2:buffer}, ${3:length}, ${4:received_bytes})", "prefix": "dmSSLSocket::Receive(socket, buffer, length, received_bytes)", "description": "receive data on a secure socket"}], "dmScript::CheckVector3(L, index)": [{"body": "dmScript::CheckVector3(${1:L}, ${2:index})", "prefix": "dmScript::CheckVector3(L, index)", "description": "check if the value is a Vectormath::Aos::Vector3"}], "dmGraphics::GetNativeOSXNSWindow": [{"body": "dmGraphics::GetNativeOSXNSWindow()", "prefix": "dmGraphics::GetNativeOSXNSWindow", "description": "get OSX NSWindow"}], "DM_LUA_ERROR(fmt, args)": [{"body": "DM_LUA_ERROR", "prefix": "DM_LUA_ERROR(fmt, args)", "description": "helper macro to validate the Lua stack state and throw a lua error."}], "GetRotation(instance)": [{"body": "GetRotation(${1:instance})", "prefix": "GetRotation(instance)", "description": "get rotation"}], "dmScript::PCall(L, nargs, nresult)": [{"body": "dmScript::PCall(${1:L}, ${2:nargs}, ${3:nresult})", "prefix": "dmScript::PCall(L, nargs, nresult)", "description": "This function wraps lua_pcall with the addition of..."}], "dmConnectionPool::Params": [{"body": "dmConnectionPool::Params", "prefix": "dmConnectionPool::Params", "description": "Creation parameters"}], "OffsetCapacity(offset)": [{"body": "OffsetCapacity(${1:offset})", "prefix": "OffsetCapacity(offset)", "description": "array offset capacity"}], "dmHID::MAX_GAMEPAD_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_GAMEPAD_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_GAMEPAD_COUNT [type: uint32_t]", "description": "Maximum number of gamepads supported"}], "dmHashReverseSafe64(hash, length)": [{"body": "dmHashReverseSafe64(${1:hash}, ${2:length})", "prefix": "dmHashReverseSafe64(hash, length)", "description": "get string value from hash"}], "dmGraphics::GetNativeX11Window": [{"body": "dmGraphics::GetNativeX11Window()", "prefix": "dmGraphics::GetNativeX11Window", "description": "get Linux X11Window"}], "dmBuffer::GetBytes(buffer, out_bytes, out_size)": [{"body": "dmBuffer::GetBytes(${1:buffer}, ${2:out_bytes}, ${3:out_size})", "prefix": "dmBuffer::GetBytes(buffer, out_bytes, out_size)", "description": "get buffer as a byte array."}], "dmExtension::AppParams": [{"body": "dmExtension::AppParams", "prefix": "dmExtension::AppParams", "description": "application level callback data"}], "dmScript::IsInstanceValid(L)": [{"body": "dmScript::IsInstanceValid(${1:L})", "prefix": "dmScript::IsInstanceValid(L)", "description": "Check if the script instance in the lua state is v..."}], "SetBlocking(socket, blocking)": [{"body": "SetBlocking(${1:socket}, ${2:blocking})", "prefix": "SetBlocking(socket, blocking)", "description": "Set blocking option on a socket"}], "SetGamepadButton(gamepad, button, value)": [{"body": "SetGamepadButton(${1:gamepad}, ${2:button}, ${3:value})", "prefix": "SetGamepadButton(gamepad, button, value)", "description": "Sets the state of a gamepad button."}], "New(type, protocol, socket)": [{"body": "New(${1:type}, ${2:protocol}, ${3:socket})", "prefix": "New(type, protocol, socket)", "description": "create a socket"}], "GetHeader(request, name)": [{"body": "GetHeader(${1:request}, ${2:name})", "prefix": "GetHeader(request, name)", "description": "Get http header value for key"}], "HandlerParams": [{"body": "HandlerParams", "prefix": "HandlerParams", "description": "handler parameters"}], "INVALID_SOCKET_HANDLE": [{"body": "INVALID_SOCKET_HANDLE", "prefix": "INVALID_SOCKET_HANDLE", "description": "Invalid socket handle"}], "dmBuffer::Copy(dst_buffer_handle, src_buffer_handle)": [{"body": "dmBuffer::Copy(${1:dst_buffer_handle}, ${2:src_buffer_handle})", "prefix": "dmBuffer::Copy(dst_buffer_handle, src_buffer_handle)", "description": "copy a Buffer"}], "dmCrypt::HashSha512(buf, buflen, digest)": [{"body": "dmCrypt::HashSha512(${1:buf}, ${2:buflen}, ${3:digest})", "prefix": "dmCrypt::HashSha512(buf, buflen, digest)", "description": "Hash buffer using SHA512"}], "Select(selector, timeout)": [{"body": "Select(${1:selector}, ${2:timeout})", "prefix": "Select(selector, timeout)", "description": "Select for pending data"}], "GetTouchDevice(context, index)": [{"body": "GetTouchDevice(${1:context}, ${2:index})", "prefix": "GetTouchDevice(context, index)", "description": "gets a touch device handle"}], "Handler(user_data, request)": [{"body": "Handler", "prefix": "Handler(user_data, request)", "description": "Web request handler callback"}], "SceneNode": [{"body": "SceneNode", "prefix": "SceneNode", "description": "scene graph traversal node"}], "SceneNodeIterator": [{"body": "SceneNodeIterator", "prefix": "SceneNodeIterator", "description": "scene graph traversal iterator"}], "DM_PLATFORM_OSX": [{"body": "DM_PLATFORM_OSX", "prefix": "DM_PLATFORM_OSX", "description": "Set if the platform is OSX "}], "dmScript::IsCallbackValid(cbk)": [{"body": "dmScript::IsCallbackValid(${1:cbk})", "prefix": "dmScript::IsCallbackValid(cbk)", "description": "Check if Lua callback is valid."}], "HCollection": [{"body": "HCollection", "prefix": "HCollection", "description": "Gameobject collection handle"}], "AddKeyboardChar(keyboard, chr)": [{"body": "AddKeyboardChar(${1:keyboard}, ${2:chr})", "prefix": "AddKeyboardChar(keyboard, chr)", "description": "Add text input"}], "dmScript::ToMatrix4(L, index)": [{"body": "dmScript::ToMatrix4(${1:L}, ${2:index})", "prefix": "dmScript::ToMatrix4(L, index)", "description": "get the value at index as a Vectormath::Aos::Matrix4*"}], "DM_DECLARE_RESOURCE_TYPE(symbol, suffix, register_fn, deregister_fn)": [{"body": "DM_DECLARE_RESOURCE_TYPE", "prefix": "DM_DECLARE_RESOURCE_TYPE(symbol, suffix, register_fn, deregister_fn)", "description": "declare a new extension"}], "dmScript::PushQuat(L, quat)": [{"body": "dmScript::PushQuat(${1:L}, ${2:quat})", "prefix": "dmScript::PushQuat(L, quat)", "description": "push a Vectormath::Aos::Quat onto the Lua stack"}], "PropertyVar": [{"body": "PropertyVar", "prefix": "PropertyVar", "description": "property variant"}], "dmHashTable64": [{"body": "dmHashTable64()", "prefix": "dmHashTable64", "description": "Specialized hash table with uint64_t as key..."}], "DM_DECLARE_EXTENSION(symbol, name, appinit, appfinal, init, update, on_event, final)": [{"body": "DM_DECLARE_EXTENSION", "prefix": "DM_DECLARE_EXTENSION(symbol, name, appinit, appfinal, init, update, on_event, final)", "description": "declare a new extension"}], "dmScript::GetInstance(L)": [{"body": "dmScript::GetInstance(${1:L})", "prefix": "dmScript::GetInstance(L)", "description": "Retrieve current script instance from the global t..."}], "dmCrypt::HashSha256(buf, buflen, digest)": [{"body": "dmCrypt::HashSha256(${1:buf}, ${2:buflen}, ${3:digest})", "prefix": "dmCrypt::HashSha256(buf, buflen, digest)", "description": "Hash buffer using SHA256"}], "SetReuseAddress(socket, reuse)": [{"body": "SetReuseAddress(${1:socket}, ${2:reuse})", "prefix": "SetReuseAddress(socket, reuse)", "description": "Set reuse socket address option on socket. Socket ..."}], "Parse(buffer, length, document)": [{"body": "Parse(${1:buffer}, ${2:length}, ${3:document})", "prefix": "Parse(buffer, length, document)", "description": "parse json data"}], "~dmArray": [{"body": "~dmArray()", "prefix": "~dmArray", "description": "array destructor"}], "SetPosition(instance, position)": [{"body": "SetPosition(${1:instance}, ${2:position})", "prefix": "SetPosition(instance, position)", "description": "set position"}], "dmConditionVariable::Signal(condition)": [{"body": "dmConditionVariable::Signal(${1:condition})", "prefix": "dmConditionVariable::Signal(condition)", "description": "signal condition variable"}], "dmScript::GetCallbackLuaContext(cbk)": [{"body": "dmScript::GetCallbackLuaContext(${1:cbk})", "prefix": "dmScript::GetCallbackLuaContext(cbk)", "description": "Gets the Lua context from a callback struct"}], "dmMutex::HMutex": [{"body": "dmMutex::HMutex", "prefix": "dmMutex::HMutex", "description": "HMutex type definition"}], "dmBuffer::UpdateContentVersion(type)": [{"body": "dmBuffer::UpdateContentVersion(${1:type})", "prefix": "dmBuffer::UpdateContentVersion(type)", "description": "Update the internal frame counter."}], "DM_ALIGN(x, a)": [{"body": "DM_ALIGN", "prefix": "DM_ALIGN(x, a)", "description": "value alignment macro"}], "AddTouch(device, x, y, id, phase)": [{"body": "AddTouch(${1:device}, ${2:x}, ${3:y}, ${4:id}, ${5:phase})", "prefix": "AddTouch(device, x, y, id, phase)", "description": "Adds a touch event touch."}], "DM_PLATFORM_ANDROID": [{"body": "DM_PLATFORM_ANDROID", "prefix": "DM_PLATFORM_ANDROID", "description": "Set if the platform is Android "}], "GamepadPacket": [{"body": "GamepadPacket", "prefix": "GamepadPacket", "description": "Contains the current state of a gamepad"}], "dmHID::MAX_TOUCH_DEVICE_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_TOUCH_DEVICE_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_TOUCH_DEVICE_COUNT [type: uint32_t]", "description": "Maximum number of touch devices supported"}], "Back": [{"body": "Back()", "prefix": "Back", "description": "array back"}, {"body": "Back()", "prefix": "Back", "description": "array back (const)"}], "ShutdownType": [{"body": "ShutdownType", "prefix": "ShutdownType", "description": "socket shutdown type"}], "dmConditionVariable::Delete(mutex)": [{"body": "dmConditionVariable::Delete(${1:mutex})", "prefix": "dmConditionVariable::Delete(mutex)", "description": "delete condition variable"}], "SelectorSet(selector, selector_kind, socket)": [{"body": "SelectorSet(${1:selector}, ${2:selector_kind}, ${3:socket})", "prefix": "SelectorSet(selector, selector_kind, socket)", "description": "Set selector for socket. Similar to FD_SET"}], "dmHID::MAX_GAMEPAD_HAT_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_GAMEPAD_HAT_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_GAMEPAD_HAT_COUNT [type: uint32_t]", "description": "Maximum number of gamepad hats supported"}], "dmScript::CheckVector4(L, index)": [{"body": "dmScript::CheckVector4(${1:L}, ${2:index})", "prefix": "dmScript::CheckVector4(L, index)", "description": "check if the value is a Vectormath::Aos::Vector3"}], "operator[](index)": [{"body": "operator[](${1:index})", "prefix": "operator[](index)", "description": "array operator[]"}, {"body": "operator[](${1:index})", "prefix": "operator[](index)", "description": "array operator[] (const)"}], "GetGameObjectRegister(app_params)": [{"body": "GetGameObjectRegister(${1:app_params})", "prefix": "GetGameObjectRegister(app_params)", "description": "get the game object register"}], "dmConnectionPool::Delete(pool)": [{"body": "dmConnectionPool::Delete(${1:pool})", "prefix": "dmConnectionPool::Delete(pool)", "description": "Delete connnection pool"}], "dmScript::SetInstance(L)": [{"body": "dmScript::SetInstance(${1:L})", "prefix": "dmScript::SetInstance(L)", "description": "Sets the current script instance\nSet the value on ..."}], "Socket": [{"body": "Socket", "prefix": "Socket", "description": "Socket type definition"}, {"body": "Socket", "prefix": "Socket", "description": "Socket type definition"}], "Begin": [{"body": "Begin()", "prefix": "Begin", "description": "array begin"}], "dmGraphics::GetNativeAndroidEGLContext": [{"body": "dmGraphics::GetNativeAndroidEGLContext()", "prefix": "dmGraphics::GetNativeAndroidEGLContext", "description": "get Android EGLContext"}], "DM_DLLEXPORT": [{"body": "DM_DLLEXPORT", "prefix": "DM_DLLEXPORT", "description": "storage-class attribute for shared library export/import"}], "SetGamepadAxis(gamepad, axis, value)": [{"body": "SetGamepadAxis(${1:gamepad}, ${2:axis}, ${3:value})", "prefix": "SetGamepadAxis(gamepad, axis, value)", "description": "Sets the state of a gamepad axis."}], "dmScript::DestroyCallback(cbk)": [{"body": "dmScript::DestroyCallback(${1:cbk})", "prefix": "dmScript::DestroyCallback(cbk)", "description": "Deletes the Lua callback"}], "ValueType": [{"body": "ValueType", "prefix": "ValueType", "description": "valueType enumeration"}], "dmGraphics::GetNativeAndroidEGLSurface": [{"body": "dmGraphics::GetNativeAndroidEGLSurface()", "prefix": "dmGraphics::GetNativeAndroidEGLSurface", "description": "get Android EGLSurface"}], "SetMousePosition(mouse, x, y)": [{"body": "SetMousePosition(${1:mouse}, ${2:x}, ${3:y})", "prefix": "SetMousePosition(mouse, x, y)", "description": "Sets the position of a mouse."}], "dmGraphics::GetNativeOSXNSOpenGLContext": [{"body": "dmGraphics::GetNativeOSXNSOpenGLContext()", "prefix": "dmGraphics::GetNativeOSXNSOpenGLContext", "description": "get OSX NSOpenGLContext"}], "dmHID::INVALID_GAMEPAD_HANDLE [type: dmHID::HGamepad]": [{"body": "dmHID::INVALID_GAMEPAD_HANDLE [type: dmHID::HGamepad]()", "prefix": "dmHID::INVALID_GAMEPAD_HANDLE [type: dmHID::HGamepad]", "description": "invalid gamepad handle"}], "extension_callback_t(params)": [{"body": "extension_callback_t", "prefix": "extension_callback_t(params)", "description": "Extra extension callback typedef"}], "Map(fn, ctx)": [{"body": "Map(${1:fn}, ${2:ctx})", "prefix": "Map(fn, ctx)", "description": "map a function on all values"}], "dmScript::PushVector4(L, v)": [{"body": "dmScript::PushVector4(${1:L}, ${2:v})", "prefix": "dmScript::PushVector4(L, v)", "description": "push a Vectormath::Aos::Vector4 on the stack"}], "GetWorldPosition(instance)": [{"body": "GetWorldPosition(${1:instance})", "prefix": "GetWorldPosition(instance)", "description": "get world position"}], "SelectorIsSet(selector, selector_kind, socket)": [{"body": "SelectorIsSet(${1:selector}, ${2:selector_kind}, ${3:socket})", "prefix": "SelectorIsSet(selector, selector_kind, socket)", "description": "Check if selector is set. Similar to FD_ISSET"}], "HPool": [{"body": "HPool", "prefix": "HPool", "description": "Connection pool handle"}], "Phase": [{"body": "Phase", "prefix": "Phase", "description": "touch phase enumeration"}], "dmGraphics::GetNativeAndroidActivity": [{"body": "dmGraphics::GetNativeAndroidActivity()", "prefix": "dmGraphics::GetNativeAndroidActivity", "description": "get Android native jobject"}], "dmLogError(format, args)": [{"body": "dmLogError(${1:format}, ${2:args})", "prefix": "dmLogError(format, args)", "description": "log with \"error\" severity"}], "HScriptInstance": [{"body": "HScriptInstance", "prefix": "HScriptInstance", "description": "Script instance handle"}], "dmSSLSocket::Result": [{"body": "dmSSLSocket::Result", "prefix": "dmSSLSocket::Result", "description": "result enumeration"}], "UnregisterAndroidOnActivityResultListener([type:dmExtension::OnActivityResult])": [{"body": "UnregisterAndroidOnActivityResultListener(${1:[type:dmExtension::OnActivityResult]})", "prefix": "UnregisterAndroidOnActivityResultListener([type:dmExtension::OnActivityResult])", "description": "unregister Android activity result callback"}], "RegisterCallback(callback_type, func)": [{"body": "RegisterCallback(${1:callback_type}, ${2:func})", "prefix": "RegisterCallback(callback_type, func)", "description": "Register extra extension callbacks."}], "GetConfigFile(app_params)": [{"body": "GetConfigFile(${1:app_params})", "prefix": "GetConfigFile(app_params)", "description": "get the config file"}], "MousePacket": [{"body": "MousePacket", "prefix": "MousePacket", "description": "Contains the current state of a mouse"}], "DM_DEBUG": [{"body": "DM_DEBUG", "prefix": "DM_DEBUG", "description": "define for debug builds"}], "MouseButton": [{"body": "MouseButton", "prefix": "MouseButton", "description": "mouse button enumeration"}], "Request": [{"body": "Request", "prefix": "Request", "description": "web server request"}], "GetUniformScale(instance)": [{"body": "GetUniformScale(${1:instance})", "prefix": "GetUniformScale(instance)", "description": "get uniform scale"}], "dmSocket::SetReceiveTimeout(socket, timeout)": [{"body": "dmSocket::SetReceiveTimeout(${1:socket}, ${2:timeout})", "prefix": "dmSocket::SetReceiveTimeout(socket, timeout)", "description": "Set socket receive timeout"}], "dmExtension::Params": [{"body": "dmExtension::Params", "prefix": "dmExtension::Params", "description": "extension level callback data"}], "DM_PLATFORM_HTML5": [{"body": "DM_PLATFORM_HTML5", "prefix": "DM_PLATFORM_HTML5", "description": "Set if the platform is Html5 "}], "GetGamePad(context, index)": [{"body": "GetGamePad(${1:context}, ${2:index})", "prefix": "GetGamePad(context, index)", "description": "gets a gamepad device handle"}], "SceneNodePropertyType": [{"body": "SceneNodePropertyType", "prefix": "SceneNodePropertyType", "description": "scene node property types"}], "dmConfigFile::GetInt(config, key, default_value)": [{"body": "dmConfigFile::GetInt(${1:config}, ${2:key}, ${3:default_value})", "prefix": "dmConfigFile::GetInt(config, key, default_value)", "description": "get config value as int"}], "dmScript::CreateCallback(L, index)": [{"body": "dmScript::CreateCallback(${1:L}, ${2:index})", "prefix": "dmScript::CreateCallback(L, index)", "description": "Register a Lua callback."}], "SelectorZero(selector)": [{"body": "SelectorZero(${1:selector})", "prefix": "SelectorZero(selector)", "description": "Clear selector (all kinds). Similar to FD_ZERO"}], "TraverseIteratePropertiesNext(it)": [{"body": "TraverseIteratePropertiesNext(${1:it})", "prefix": "TraverseIteratePropertiesNext(it)", "description": "Steps the scene node traversal property iterator t..."}], "dmHashReverseSafe64(hash)": [{"body": "dmHashReverseSafe64(${1:hash})", "prefix": "dmHashReverseSafe64(hash)", "description": "get string value from hash"}], "Parse(buffer, document)": [{"body": "Parse(${1:buffer}, ${2:document})", "prefix": "Parse(buffer, document)", "description": "parse null terminated json data"}], "PushArray(array, count)": [{"body": "PushArray(${1:array}, ${2:count})", "prefix": "PushArray(array, count)", "description": "array push array"}], "Receive(request, buffer, buffer_size, received_bytes)": [{"body": "Receive(${1:request}, ${2:buffer}, ${3:buffer_size}, ${4:received_bytes})", "prefix": "Receive(request, buffer, buffer_size, received_bytes)", "description": "Receive data"}], "dmGraphics::GetNativeiOSUIWindow": [{"body": "dmGraphics::GetNativeiOSUIWindow()", "prefix": "dmGraphics::GetNativeiOSUIWindow", "description": "get iOS UIWindow"}], "EraseSwapRef(element)": [{"body": "EraseSwapRef(${1:element})", "prefix": "EraseSwapRef(element)", "description": "array reference eraseswap"}], "GetHostByName(name, address, ipv4, ipv6)": [{"body": "GetHostByName(${1:name}, ${2:address}, ${3:ipv4}, ${4:ipv6})", "prefix": "GetHostByName(name, address, ipv4, ipv6)", "description": "get host by name"}], "dmThread::New(thread_start, stack_size, arg, name)": [{"body": "dmThread::New(${1:thread_start}, ${2:stack_size}, ${3:arg}, ${4:name})", "prefix": "dmThread::New(thread_start, stack_size, arg, name)", "description": "create a new thread"}], "dmConnectionPool::Dial(pool, host, port, ssl, timeout, connection, sock_res)": [{"body": "dmConnectionPool::Dial(${1:pool}, ${2:host}, ${3:port}, ${4:ssl}, ${5:timeout}, ${6:connection}, ${7:sock_res})", "prefix": "dmConnectionPool::Dial(pool, host, port, ssl, timeout, connection, sock_res)", "description": "Connection to a host/port"}], "TraverseIterateNext(it)": [{"body": "TraverseIterateNext(${1:it})", "prefix": "TraverseIterateNext(it)", "description": "Step a scene node iterator to the next sibling"}], "dmCrypt::HashMd5(buf, buflen, digest)": [{"body": "dmCrypt::HashMd5(${1:buf}, ${2:buflen}, ${3:digest})", "prefix": "dmCrypt::HashMd5(buf, buflen, digest)", "description": "Hash buffer using MD5"}], "HServer": [{"body": "HServer", "prefix": "HServer", "description": "web server handle"}], "PropertyType": [{"body": "PropertyType", "prefix": "PropertyType", "description": "property types"}], "dmExtension::CallbackType": [{"body": "dmExtension::CallbackType", "prefix": "dmExtension::CallbackType", "description": "extra callback enumeration"}], "EraseSwap(index)": [{"body": "EraseSwap(${1:index})", "prefix": "EraseSwap(index)", "description": "array eraseswap"}], "dmHashBuffer64(buffer, buffer_len)": [{"body": "dmHashBuffer64(${1:buffer}, ${2:buffer_len})", "prefix": "dmHashBuffer64(buffer, buffer_len)", "description": "calculate 64-bit hash value from buffer"}], "dmBuffer::Destroy(buffer)": [{"body": "dmBuffer::Destroy(${1:buffer})", "prefix": "dmBuffer::Destroy(buffer)", "description": "destroy Buffer."}], "dmMutex::Delete(mutex)": [{"body": "dmMutex::Delete(${1:mutex})", "prefix": "dmMutex::Delete(mutex)", "description": "delete Mutex."}], "GetWorldRotation(instance)": [{"body": "GetWorldRotation(${1:instance})", "prefix": "GetWorldRotation(instance)", "description": "get world rotation"}], "dmJson::Type(L, doc, index, error_str_out, error_str_size)": [{"body": "dmJson::Type(${1:L}, ${2:doc}, ${3:index}, ${4:error_str_out}, ${5:error_str_size})", "prefix": "dmJson::Type(L, doc, index, error_str_out, error_str_size)", "description": "convert a dmJson::Document to a Lua table"}]}