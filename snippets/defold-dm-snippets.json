{"": [{"body": "()", "prefix": "", "description": "Callback when iterating over the properties for a ..."}], "SendAttribute(request, key, value)": [{"body": "SendAttribute(${1:request}, ${2:key}, ${3:value})", "prefix": "SendAttribute(request, key, value)", "description": "Sends a header attribute"}], "dmScript::Ref(L, table)": [{"body": "dmScript::Ref(${1:L}, ${2:table})", "prefix": "dmScript::Ref(L, table)", "description": "wrapper for luaL_ref."}], "HConnection": [{"body": "HConnection", "prefix": "HConnection", "description": "Connection handle"}], "GetActivity": [{"body": "GetActivity()", "prefix": "GetActivity", "description": "Gets the app native activity"}], "CreateRenderConstants": [{"body": "CreateRenderConstants()", "prefix": "CreateRenderConstants", "description": "Create a new HComponentRenderConstants container"}], "GetKeyboard(context, index)": [{"body": "GetKeyboard(${1:context}, ${2:index})", "prefix": "GetKeyboard(context, index)", "description": "gets a keyboard handle"}], "dmHashTable32": [{"body": "dmHashTable32()", "prefix": "dmHashTable32", "description": "Specialized hash table with uint32_t as key..."}], "dmThread::FreeTls(key)": [{"body": "dmThread::FreeTls(${1:key})", "prefix": "dmThread::FreeTls(key)", "description": "free thread local storage key"}], "ComponentTypeSetHasUserData(type, has_user_data)": [{"body": "ComponentTypeSetHasUserData(${1:type}, ${2:has_user_data})", "prefix": "ComponentTypeSetHasUserData(type, has_user_data)", "description": "set the component type need for a per component instance user data"}], "ToTransform(mtx)": [{"body": "ToTransform(${1:mtx})", "prefix": "ToTransform(mtx)", "description": "Convert a matrix into a transform"}], "dmGraphics::GetNativeWindowsHGLRC": [{"body": "dmGraphics::GetNativeWindowsHGLRC()", "prefix": "dmGraphics::GetNativeWindowsHGLRC", "description": "get Win32 HGLRC"}], "dmHID::HGamepad": [{"body": "dmHID::HGamepad", "prefix": "dmHID::HGamepad", "description": "gamepad context handle"}], "ParseResult": [{"body": "ParseResult", "prefix": "ParseResult", "description": "header parse result enumeration"}], "dmCrypt::Base64Encode(src, src_len, dst, dst_len[in,out])": [{"body": "dmCrypt::Base64Encode(${1:src}, ${2:src_len}, ${3:dst}, ${4:dst_len[in,out]})", "prefix": "dmCrypt::Base64Encode(src, src_len, dst, dst_len[in,out])", "description": "Base64 encode a buffer"}], "RenderListOperation": [{"body": "RenderListOperation", "prefix": "RenderListOperation", "description": "Render batch callback states"}], "dmScript::IsVector4(L, index)": [{"body": "dmScript::IsVector4(${1:L}, ${2:index})", "prefix": "dmScript::IsVector4(L, index)", "description": "Check if the value at #index is a Vectormath::Aos:..."}], "Protocol": [{"body": "Protocol", "prefix": "Protocol", "description": "network protocol"}], "OnActivityCreate(env, activity)": [{"body": "OnActivityCreate", "prefix": "OnActivityCreate(env, activity)", "description": "OnActivityCreate callback typedef"}], "OnActivityResult(env, activity, request_code, result_code, result)": [{"body": "OnActivityResult", "prefix": "OnActivityResult(env, activity, request_code, result_code, result)", "description": "OnActivityResult callback typedef"}], "SetConstantValues(constant, values, num_values)": [{"body": "SetConstantValues(${1:constant}, ${2:values}, ${3:num_values})", "prefix": "SetConstantValues(constant, values, num_values)", "description": "Sets the shader program constant values"}], "AddToRender(context, ro)": [{"body": "AddToRender(${1:context}, ${2:ro})", "prefix": "AddToRender(context, ro)", "description": "Adds a render object to the current render frame"}], "dmConnectionPool::GetSSLSocket(pool, connection)": [{"body": "dmConnectionPool::GetSSLSocket(${1:pool}, ${2:connection})", "prefix": "dmConnectionPool::GetSSLSocket(pool, connection)", "description": "Get secure socket."}], "LoadMessage<T>(buffer, buffer_size, message)": [{"body": "LoadMessage<T>(${1:buffer}, ${2:buffer_size}, ${3:message})", "prefix": "LoadMessage<T>(buffer, buffer_size, message)", "description": "Load/decode a DDF message from buffer. Template va..."}], "dmTime::Sleep(useconds)": [{"body": "dmTime::Sleep(${1:useconds})", "prefix": "dmTime::Sleep(useconds)", "description": "sleep thread with low precision (~10 milliseconds)."}], "Min([type:class, [type:class)": [{"body": "Min(${1:[type:class}, ${2:[type:class})", "prefix": "Min([type:class, [type:class)", "description": "Min function"}], "dmTime::GetTime": [{"body": "dmTime::GetTime()", "prefix": "dmTime::GetTime", "description": "get current time in microseconds"}], "Inv(t)": [{"body": "Inv(${1:t})", "prefix": "Inv(t)", "description": "Invert a transform"}], "dmThread::GetTlsValue(key)": [{"body": "dmThread::GetTlsValue(${1:key})", "prefix": "dmThread::GetTlsValue(key)", "description": "get thread specific data"}], "GetCollection(instance)": [{"body": "GetCollection(${1:instance})", "prefix": "GetCollection(instance)", "description": "Retrieve a collection from the specified instance"}], "dmConfigFile::GetString(config, key, default_value)": [{"body": "dmConfigFile::GetString(${1:config}, ${2:key}, ${3:default_value})", "prefix": "dmConfigFile::GetString(config, key, default_value)", "description": "get config value as string"}], "DM_DECLARE_RESOURCE_TYPE(symbol, suffix, register_fn, deregister_fn)": [{"body": "DM_DECLARE_RESOURCE_TYPE", "prefix": "DM_DECLARE_RESOURCE_TYPE(symbol, suffix, register_fn, deregister_fn)", "description": "declare a new extension"}], "DM_PLATFORM_IOS": [{"body": "DM_PLATFORM_IOS", "prefix": "DM_PLATFORM_IOS", "description": "Set if the platform is iPhoneOS "}], "ComponentTypeCreateCtx": [{"body": "ComponentTypeCreateCtx", "prefix": "ComponentTypeCreateCtx", "description": "Context used when registering a new component type"}], "dmScript::PushVector4(L, v)": [{"body": "dmScript::PushVector4(${1:L}, ${2:v})", "prefix": "dmScript::PushVector4(L, v)", "description": "push a Vectormath::Aos::Vector4 on the stack"}], "Connect(socket, address, port)": [{"body": "Connect(${1:socket}, ${2:address}, ${3:port})", "prefix": "Connect(socket, address, port)", "description": "make a connection"}], "UnregisterOnActivityResultListener([type:dmAndroid::OnActivityResult])": [{"body": "UnregisterOnActivityResultListener(${1:[type:dmAndroid::OnActivityResult]})", "prefix": "UnregisterOnActivityResultListener([type:dmAndroid::OnActivityResult])", "description": "unregister Android activity result callback"}], "SetMouseWheel(mouse, value)": [{"body": "SetMouseWheel(${1:mouse}, ${2:value})", "prefix": "SetMouseWheel(mouse, value)", "description": "Sets the mouse wheel."}], "SceneNode": [{"body": "SceneNode", "prefix": "SceneNode", "description": "scene graph traversal node"}], "dmScript::Unref(L, table, reference)": [{"body": "dmScript::Unref(${1:L}, ${2:table}, ${3:reference})", "prefix": "dmScript::Unref(L, table, reference)", "description": "wrapper for luaL_unref."}], "PreloadHint(factory, name)": [{"body": "PreloadHint(${1:factory}, ${2:name})", "prefix": "PreloadHint(factory, name)", "description": "Hint the preloader what to load before Create is c..."}], "GetWebServer(app_params)": [{"body": "GetWebServer(${1:app_params})", "prefix": "GetWebServer(app_params)", "description": "get the web server handle"}], "DM_HEADLESS": [{"body": "DM_HEADLESS", "prefix": "DM_HEADLESS", "description": "define for headless builds"}], "HComponentRenderConstants": [{"body": "HComponentRenderConstants", "prefix": "HComponentRenderConstants", "description": "Render constants handle"}], "dmExtension::Event": [{"body": "dmExtension::Event", "prefix": "dmExtension::Event", "description": "event callback data"}], "dmBuffer::Create(count, streams_decl, streams_decl_count, out_buffer)": [{"body": "dmBuffer::Create(${1:count}, ${2:streams_decl}, ${3:streams_decl_count}, ${4:out_buffer})", "prefix": "dmBuffer::Create(count, streams_decl, streams_decl_count, out_buffer)", "description": "create Buffer"}], "DLIB_LOG_DOMAIN": [{"body": "DLIB_LOG_DOMAIN", "prefix": "DLIB_LOG_DOMAIN", "description": "macro for debug category logging"}], "SetRotation(rotation)": [{"body": "SetRotation(${1:rotation})", "prefix": "SetRotation(rotation)", "description": "set rotatiom"}], "GetConstantLocation(constant)": [{"body": "GetConstantLocation(${1:constant})", "prefix": "GetConstantLocation(constant)", "description": "Gets the shader program constant location"}], "dmMessage::URL": [{"body": "dmMessage::URL", "prefix": "dmMessage::URL", "description": "URL specifying a sender/receiver of messages"}], "dmStrCaseCmp(s1, s2)": [{"body": "dmStrCaseCmp(${1:s1}, ${2:s2})", "prefix": "dmStrCaseCmp(s1, s2)", "description": "Case-insensitive string comparison"}], "Descriptor": [{"body": "Descriptor", "prefix": "Descriptor", "description": "descriptor handle"}], "dmConfigFile::GetInt(config, key, default_value)": [{"body": "dmConfigFile::GetInt(${1:config}, ${2:key}, ${3:default_value})", "prefix": "dmConfigFile::GetInt(config, key, default_value)", "description": "get config value as int"}], "dmBuffer::GetStream(buffer, stream_name, stream, count, components, stride)": [{"body": "dmBuffer::GetStream(${1:buffer}, ${2:stream_name}, ${3:stream}, ${4:count}, ${5:components}, ${6:stride})", "prefix": "dmBuffer::GetStream(buffer, stream_name, stream, count, components, stride)", "description": "get stream from buffer."}], "dmScript::CheckBuffer(L, index)": [{"body": "dmScript::CheckBuffer(${1:L}, ${2:index})", "prefix": "dmScript::CheckBuffer(L, index)", "description": "retrieve a HBuffer from the supplied lua state"}], "RefInInstance(L)": [{"body": "RefInInstance(${1:L})", "prefix": "RefInInstance(L)", "description": "Creates a reference to the value at top of stack, ..."}], "SelectorKind": [{"body": "SelectorKind", "prefix": "SelectorKind", "description": "Selector kind"}], "dmCrypt::HashSha1(buf, buflen, digest)": [{"body": "dmCrypt::HashSha1(${1:buf}, ${2:buflen}, ${3:digest})", "prefix": "dmCrypt::HashSha1(buf, buflen, digest)", "description": "Hash buffer using SHA1"}], "Capacity": [{"body": "Capacity()", "prefix": "Capacity", "description": "capacity of array"}], "ComponentTypeSetChildIteratorFn(type, fn)": [{"body": "ComponentTypeSetChildIteratorFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetChildIteratorFn(type, fn)", "description": "set the component child iterator function"}], "dmGraphics::GetNativeWindowsHWND": [{"body": "dmGraphics::GetNativeWindowsHWND()", "prefix": "dmGraphics::GetNativeWindowsHWND", "description": "get Win32 HWND"}], "GetRenderConstantCount(constants)": [{"body": "GetRenderConstantCount(${1:constants})", "prefix": "GetRenderConstantCount(constants)", "description": "Get the number of render constants"}], "dmExtension::EventID": [{"body": "dmExtension::EventID", "prefix": "dmExtension::EventID", "description": "event id enumeration"}], "SetFragment(url, fragment)": [{"body": "SetFragment(${1:url}, ${2:fragment})", "prefix": "SetFragment(url, fragment)", "description": "Set the message fragment"}], "dmConnectionPool::Result": [{"body": "dmConnectionPool::Result", "prefix": "dmConnectionPool::Result", "description": "result enumeration"}], "UnregisterOnActivityCreateListener([type:dmAndroid::OnActivityCreate])": [{"body": "UnregisterOnActivityCreateListener(${1:[type:dmAndroid::OnActivityCreate]})", "prefix": "UnregisterOnActivityCreateListener([type:dmAndroid::OnActivityCreate])", "description": "unregister Android onCreate callback"}], "dmLogWarning(format, args)": [{"body": "dmLogWarning(${1:format}, ${2:args})", "prefix": "dmLogWarning(format, args)", "description": "log with \"warning\" severity"}], "DM_ARRAY_SIZE(Array)": [{"body": "DM_ARRAY_SIZE", "prefix": "DM_ARRAY_SIZE(Array)", "description": "get number of elements in C array"}], "ComponentTypeSetDeleteWorldFn(type, fn)": [{"body": "ComponentTypeSetDeleteWorldFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetDeleteWorldFn(type, fn)", "description": "set the world destroy callback"}], "RenderListDispatchParams": [{"body": "RenderListDispatchParams", "prefix": "RenderListDispatchParams", "description": "Render dispatch function callback."}], "dmHID::MAX_TOUCH_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_TOUCH_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_TOUCH_COUNT [type: uint32_t]", "description": "Maximum number of simultaneous touches supported"}], "RenderListDispatchFn(params)": [{"body": "RenderListDispatchFn", "prefix": "RenderListDispatchFn(params)", "description": "Render dispatch function callback."}], "dmScript::CheckMatrix4(L, index)": [{"body": "dmScript::CheckMatrix4(${1:L}, ${2:index})", "prefix": "dmScript::CheckMatrix4(L, index)", "description": "check if the value is a Vectormath::Aos::Matrix4"}], "dmBuffer::HBuffer": [{"body": "dmBuffer::HBuffer", "prefix": "dmBuffer::HBuffer", "description": "HBuffer type definition"}], "dmHashString32(string)": [{"body": "dmHashString32(${1:string})", "prefix": "dmHashString32(string)", "description": "Calculate 32-bit hash value from string"}], "Free(document)": [{"body": "Free(${1:document})", "prefix": "Free(document)", "description": "deallocates json document"}], "dmSnPrintf(buffer, count, format)": [{"body": "dmSnPrintf(${1:buffer}, ${2:count}, ${3:format})", "prefix": "dmSnPrintf(buffer, count, format)", "description": "Size-bounded string formating."}], "GetMessageSocket(collection)": [{"body": "GetMessageSocket(${1:collection})", "prefix": "GetMessageSocket(collection)", "description": "Retrieve the message socket for the specified coll..."}], "dmHID::MAX_TOUCH_DEVICE_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_TOUCH_DEVICE_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_TOUCH_DEVICE_COUNT [type: uint32_t]", "description": "Maximum number of touch devices supported"}], "dmBuffer::GetBytes(buffer, out_bytes, out_size)": [{"body": "dmBuffer::GetBytes(${1:buffer}, ${2:out_bytes}, ${3:out_size})", "prefix": "dmBuffer::GetBytes(buffer, out_bytes, out_size)", "description": "get buffer as a byte array."}], "dmScript::IsInstanceValid(L)": [{"body": "dmScript::IsInstanceValid(${1:L})", "prefix": "dmScript::IsInstanceValid(L)", "description": "Check if the script instance in the lua state is v..."}], "dmRender::RenderObject::MAX_TEXTURE_COUNT": [{"body": "dmRender::RenderObject::MAX_TEXTURE_COUNT()", "prefix": "dmRender::RenderObject::MAX_TEXTURE_COUNT", "description": "The maximum number of textures the render object c..."}], "New(type, protocol, socket)": [{"body": "New(${1:type}, ${2:protocol}, ${3:socket})", "prefix": "New(type, protocol, socket)", "description": "create a socket"}], "GetHeader(request, name)": [{"body": "GetHeader(${1:request}, ${2:name})", "prefix": "GetHeader(request, name)", "description": "Get http header value for key"}], "dmHashRelease32(hash_state)": [{"body": "dmHashRelease32(${1:hash_state})", "prefix": "dmHashRelease32(hash_state)", "description": "Release incremental hashing resources\nUsed to rele..."}], "IsAttached": [{"body": "IsAttached()", "prefix": "IsAttached", "description": "Is the environment attached and valid?"}], "dmScript::IsHash(L, index)": [{"body": "dmScript::IsHash(${1:L}, ${2:index})", "prefix": "dmScript::IsHash(L, index)", "description": "Check if the value at #index is a hash"}], "NewVertexDeclaration(context, element, count)": [{"body": "NewVertexDeclaration(${1:context}, ${2:element}, ${3:count})", "prefix": "NewVertexDeclaration(context, element, count)", "description": "Create new vertex declaration"}], "dmSSLSocket::New(socket, host, timeout, sslsocket)": [{"body": "dmSSLSocket::New(${1:socket}, ${2:host}, ${3:timeout}, ${4:sslsocket})", "prefix": "dmSSLSocket::New(socket, host, timeout, sslsocket)", "description": "create a secure socket"}], "Select(selector, timeout)": [{"body": "Select(${1:selector}, ${2:timeout})", "prefix": "Select(selector, timeout)", "description": "Select for pending data"}], "LoadClass": [{"body": "LoadClass()", "prefix": "LoadClass", "description": "Load a class"}], "dmScript::IsCallbackValid(cbk)": [{"body": "dmScript::IsCallbackValid(${1:cbk})", "prefix": "dmScript::IsCallbackValid(cbk)", "description": "Check if Lua callback is valid."}], "HCollection": [{"body": "HCollection", "prefix": "HCollection", "description": "Gameobject collection handle"}], "SOCKET_TIMEOUT": [{"body": "SOCKET_TIMEOUT", "prefix": "SOCKET_TIMEOUT", "description": "Socket default timeout value"}], "ApplyNoScaleZ(t, p)": [{"body": "ApplyNoScaleZ(${1:t}, ${2:p})", "prefix": "ApplyNoScaleZ(t, p)", "description": "Apply the transform on a point, but without scalin..."}], "CheckGOInstance(L)": [{"body": "CheckGOInstance(${1:L})", "prefix": "CheckGOInstance(L)", "description": "Get current game object instance\nWorks in both gam..."}], "PropertyVar": [{"body": "PropertyVar", "prefix": "PropertyVar", "description": "property variant"}], "dmHashTable64": [{"body": "dmHashTable64()", "prefix": "dmHashTable64", "description": "Specialized hash table with uint64_t as key..."}], "dmScript::GetInstance(L)": [{"body": "dmScript::GetInstance(${1:L})", "prefix": "dmScript::GetInstance(L)", "description": "Retrieve current script instance from the global t..."}], "Release(factory, resource)": [{"body": "Release(${1:factory}, ${2:resource})", "prefix": "Release(factory, resource)", "description": "Release resource"}], "HVertexProgram": [{"body": "HVertexProgram", "prefix": "HVertexProgram", "description": "Vertex program handle"}], "dmMutex::HMutex": [{"body": "dmMutex::HMutex", "prefix": "dmMutex::HMutex", "description": "HMutex type definition"}], "HContext": [{"body": "HContext", "prefix": "HContext", "description": "Context handle"}, {"body": "HContext", "prefix": "HContext", "description": "The script context"}], "dmConditionVariable::Delete(mutex)": [{"body": "dmConditionVariable::Delete(${1:mutex})", "prefix": "dmConditionVariable::Delete(mutex)", "description": "delete condition variable"}], "SetIdentifier(collection, instance, identifier)": [{"body": "SetIdentifier(${1:collection}, ${2:instance}, ${3:identifier})", "prefix": "SetIdentifier(collection, instance, identifier)", "description": "Set instance identifier. Must be unique within the..."}], "operator[](index)": [{"body": "operator[](${1:index})", "prefix": "operator[](index)", "description": "array operator[]"}, {"body": "operator[](${1:index})", "prefix": "operator[](index)", "description": "array operator[] (const)"}], "dmScript::SetInstance(L)": [{"body": "dmScript::SetInstance(${1:L})", "prefix": "dmScript::SetInstance(L)", "description": "Sets the current script instance\nSet the value on ..."}], "Socket": [{"body": "Socket", "prefix": "Socket", "description": "Socket type definition"}, {"body": "Socket", "prefix": "Socket", "description": "Socket type definition"}], "PropertyDesc": [{"body": "PropertyDesc", "prefix": "PropertyDesc", "description": "Description of a property"}], "dmHashTable": [{"body": "dmHashTable()", "prefix": "dmHashTable", "description": "hashtable"}], "ValueType": [{"body": "ValueType", "prefix": "ValueType", "description": "valueType enumeration"}], "dmGraphics::GetNativeOSXNSOpenGLContext": [{"body": "dmGraphics::GetNativeOSXNSOpenGLContext()", "prefix": "dmGraphics::GetNativeOSXNSOpenGLContext", "description": "get OSX NSOpenGLContext"}], "extension_callback_t(params)": [{"body": "extension_callback_t", "prefix": "extension_callback_t(params)", "description": "Extra extension callback typedef"}], "MousePacket": [{"body": "MousePacket", "prefix": "MousePacket", "description": "Contains the current state of a mouse"}], "ComponentTypeSetGetPropertyFn(type, fn)": [{"body": "ComponentTypeSetGetPropertyFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetGetPropertyFn(type, fn)", "description": "set the component get property callback"}], "dmHashRelease64(hash_state)": [{"body": "dmHashRelease64(${1:hash_state})", "prefix": "dmHashRelease64(hash_state)", "description": "Release incremental hashing resources\nUsed to rele..."}], "Request": [{"body": "Request", "prefix": "Request", "description": "web server request"}], "RenderListMakeDispatch(context, fn, user_data)": [{"body": "RenderListMakeDispatch(${1:context}, ${2:fn}, ${3:user_data})", "prefix": "RenderListMakeDispatch(context, fn, user_data)", "description": "Register a render dispatch function"}], "dmScript::GetMainThread(L)": [{"body": "dmScript::GetMainThread(${1:L})", "prefix": "dmScript::GetMainThread(L)", "description": "Retrieve the main thread lua state from any lua st..."}], "Transform(translation, rotation, scale)": [{"body": "Transform(${1:translation}, ${2:rotation}, ${3:scale})", "prefix": "Transform(translation, rotation, scale)", "description": "constructor"}, {"body": "Transform(${1:translation}, ${2:rotation}, ${3:scale})", "prefix": "Transform(translation, rotation, scale)", "description": "constructor"}], "PushArray(array, count)": [{"body": "PushArray(${1:array}, ${2:count})", "prefix": "PushArray(array, count)", "description": "array push array"}], "ClearRenderConstant(constants, name_hash)": [{"body": "ClearRenderConstant(${1:constants}, ${2:name_hash})", "prefix": "ClearRenderConstant(constants, name_hash)", "description": "Removes a render constant from the container"}], "EraseSwapRef(element)": [{"body": "EraseSwapRef(${1:element})", "prefix": "EraseSwapRef(element)", "description": "array reference eraseswap"}], "HashRenderConstants(constants, state)": [{"body": "HashRenderConstants(${1:constants}, ${2:state})", "prefix": "HashRenderConstants(constants, state)", "description": "Hashes the constants"}], "dmThread::New(thread_start, stack_size, arg, name)": [{"body": "dmThread::New(${1:thread_start}, ${2:stack_size}, ${3:arg}, ${4:name})", "prefix": "dmThread::New(thread_start, stack_size, arg, name)", "description": "create a new thread"}], "dmConnectionPool::Dial(pool, host, port, ssl, timeout, connection, sock_res)": [{"body": "dmConnectionPool::Dial(${1:pool}, ${2:host}, ${3:port}, ${4:ssl}, ${5:timeout}, ${6:connection}, ${7:sock_res})", "prefix": "dmConnectionPool::Dial(pool, host, port, ssl, timeout, connection, sock_res)", "description": "Connection to a host/port"}], "FreeMessage(message)": [{"body": "FreeMessage(${1:message})", "prefix": "FreeMessage(message)", "description": "Free message"}], "AreRenderConstantsUpdated(constants)": [{"body": "AreRenderConstantsUpdated(${1:constants})", "prefix": "AreRenderConstantsUpdated(constants)", "description": "check if the constants have changed"}], "dmHashClone64(hash_state, source_hash_state, reverse_hash)": [{"body": "dmHashClone64(${1:hash_state}, ${2:source_hash_state}, ${3:reverse_hash})", "prefix": "dmHashClone64(hash_state, source_hash_state, reverse_hash)", "description": "Clone 64-bit incremental hash state"}], "IsBone(instance)": [{"body": "IsBone(${1:instance})", "prefix": "IsBone(instance)", "description": "Check whether the instance is flagged as a bone."}], "dmMutex::Delete(mutex)": [{"body": "dmMutex::Delete(${1:mutex})", "prefix": "dmMutex::Delete(mutex)", "description": "delete Mutex."}], "dmHashInit64(hash_state, reverse_hash)": [{"body": "dmHashInit64(${1:hash_state}, ${2:reverse_hash})", "prefix": "dmHashInit64(hash_state, reverse_hash)", "description": "Initialize hash-state for 64-bit incremental hashi..."}], "Empty": [{"body": "Empty()", "prefix": "Empty", "description": "array empty"}], "dmBuffer::Destroy(buffer)": [{"body": "dmBuffer::Destroy(${1:buffer})", "prefix": "dmBuffer::Destroy(buffer)", "description": "destroy Buffer."}], "Select([type:class, [type:class, [type:class)": [{"body": "Select(${1:[type:class}, ${2:[type:class}, ${3:[type:class})", "prefix": "Select([type:class, [type:class, [type:class)", "description": "Select one of two values"}], "ConstructInstanceId(index)": [{"body": "ConstructInstanceId(${1:index})", "prefix": "ConstructInstanceId(index)", "description": "Construct a hash of an instance id based on the in..."}], "dmMutex::TryLock(mutex)": [{"body": "dmMutex::TryLock(${1:mutex})", "prefix": "dmMutex::TryLock(mutex)", "description": "non-blocking lock of Mutex."}], "ComponentTypeSetInitFn(type, fn)": [{"body": "ComponentTypeSetInitFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetInitFn(type, fn)", "description": "set the component init callback"}], "ComponentTypeSetFinalFn(type, fn)": [{"body": "ComponentTypeSetFinalFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetFinalFn(type, fn)", "description": "set the component finalize callback"}], "Full": [{"body": "Full()", "prefix": "Full", "description": "array full"}], "UpdateContext": [{"body": "UpdateContext", "prefix": "UpdateContext", "description": "Update context"}], "AddHandler(server, prefix, handler_params)": [{"body": "AddHandler(${1:server}, ${2:prefix}, ${3:handler_params})", "prefix": "AddHandler(server, prefix, handler_params)", "description": "Add a new handler"}], "HSocket": [{"body": "HSocket", "prefix": "HSocket", "description": "Socket handle"}], "ResultToString(result)": [{"body": "ResultToString(${1:result})", "prefix": "ResultToString(result)", "description": "Convert result value to string"}], "dmHID::INVALID_TOUCHDEVICE_HANDLE [type: dmHID::HTouchDevice]": [{"body": "dmHID::INVALID_TOUCHDEVICE_HANDLE [type: dmHID::HTouchDevice]()", "prefix": "dmHID::INVALID_TOUCHDEVICE_HANDLE [type: dmHID::HTouchDevice]", "description": "invalid touch devicehandle"}], "DM_ALIGNED(a)": [{"body": "DM_ALIGNED", "prefix": "DM_ALIGNED(a)", "description": "data structure alignment macro"}], "HInstance": [{"body": "HInstance", "prefix": "HInstance", "description": "Gameobject instance handle"}], "GetMaxElementsVertices(context)": [{"body": "GetMaxElementsVertices(${1:context})", "prefix": "GetMaxElementsVertices(context)", "description": "Get the max number of vertices allowed by the syst..."}], "SetSendTimeout(socket, timeout)": [{"body": "SetSendTimeout(${1:socket}, ${2:timeout})", "prefix": "SetSendTimeout(socket, timeout)", "description": "Set socket send timeout"}], "dmBuffer::UpdateContentVersion(type)": [{"body": "dmBuffer::UpdateContentVersion(${1:type})", "prefix": "dmBuffer::UpdateContentVersion(type)", "description": "Update the internal frame counter."}], "dmHID::MAX_GAMEPAD_AXIS_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_GAMEPAD_AXIS_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_GAMEPAD_AXIS_COUNT [type: uint32_t]", "description": "Maximum number of gamepad axis supported"}], "HScriptInstance": [{"body": "HScriptInstance", "prefix": "HScriptInstance", "description": "Script instance handle"}], "Apply(t, v)": [{"body": "Apply(${1:t}, ${2:v})", "prefix": "Apply(t, v)", "description": "Apply the transform on a vector (excludes the tran..."}], "dmHID::INVALID_KEYBOARD_HANDLE [type: dmHID::HKeyboard]": [{"body": "dmHID::INVALID_KEYBOARD_HANDLE [type: dmHID::HKeyboard]()", "prefix": "dmHID::INVALID_KEYBOARD_HANDLE [type: dmHID::HKeyboard]", "description": "invalid keyboard handle"}], "dmLogUserDebug(format, args)": [{"body": "dmLogUserDebug(${1:format}, ${2:args})", "prefix": "dmLogUserDebug(format, args)", "description": "log with \"user\" severity"}], "BufferUsage": [{"body": "BufferUsage", "prefix": "BufferUsage", "description": ""}], "GetFD(socket)": [{"body": "GetFD(${1:socket})", "prefix": "GetFD(socket)", "description": "get underlying file descriptor"}], "ComponentTypeSetCreateFn(type, fn)": [{"body": "ComponentTypeSetCreateFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetCreateFn(type, fn)", "description": "set the component create callback"}], "CheckGOInstance(L, index)": [{"body": "CheckGOInstance(${1:L}, ${2:index})", "prefix": "CheckGOInstance(L, index)", "description": "Get gameobject instance\nThe instance reference (u..."}], "GetHIDContext(app_params)": [{"body": "GetHIDContext(${1:app_params})", "prefix": "GetHIDContext(app_params)", "description": "get the hid context"}], "LoadMessage(buffer, buffer_size, desc, message)": [{"body": "LoadMessage(${1:buffer}, ${2:buffer_size}, ${3:desc}, ${4:message})", "prefix": "LoadMessage(buffer, buffer_size, desc, message)", "description": "Load/decode a DDF message from buffer"}], "CreateResult": [{"body": "CreateResult", "prefix": "CreateResult", "description": "Create result enum"}], "dmGraphics::GetNativeX11GLXContext": [{"body": "dmGraphics::GetNativeX11GLXContext()", "prefix": "dmGraphics::GetNativeX11GLXContext", "description": "get Linux X11GLXContext"}], "dmBuffer::IsBufferValid(buffer)": [{"body": "dmBuffer::IsBufferValid(${1:buffer})", "prefix": "dmBuffer::IsBufferValid(buffer)", "description": "check buffer handle"}], "dmHashUpdateBuffer64(hash_state, buffer, buffer_len)": [{"body": "dmHashUpdateBuffer64(${1:hash_state}, ${2:buffer}, ${3:buffer_len})", "prefix": "dmHashUpdateBuffer64(hash_state, buffer, buffer_len)", "description": "Incremental hashing"}], "RenderListAlloc(context, entries)": [{"body": "RenderListAlloc(${1:context}, ${2:entries})", "prefix": "RenderListAlloc(context, entries)", "description": "Allocates an array of render entries"}], "End": [{"body": "End()", "prefix": "End", "description": "array end"}], "dmBuffer::GetValueTypeString(result)": [{"body": "dmBuffer::GetValueTypeString(${1:result})", "prefix": "dmBuffer::GetValueTypeString(result)", "description": "value type to string"}], "dmHashInit32(hash_state, reverse_hash)": [{"body": "dmHashInit32(${1:hash_state}, ${2:reverse_hash})", "prefix": "dmHashInit32(hash_state, reverse_hash)", "description": "Initialize hash-state for 32-bit incremental hashi..."}], "SetBlocking(socket, blocking)": [{"body": "SetBlocking(${1:socket}, ${2:blocking})", "prefix": "SetBlocking(socket, blocking)", "description": "Set blocking option on a socket"}], "dmConnectionPool::Close(pool, connection)": [{"body": "dmConnectionPool::Close(${1:pool}, ${2:connection})", "prefix": "dmConnectionPool::Close(pool, connection)", "description": "Close connection. Use this function whenever an er..."}], "HRenderListDispatch": [{"body": "HRenderListDispatch", "prefix": "HRenderListDispatch", "description": "Render dispatch function handle."}], "dmBuffer::GetCount(buffer, count)": [{"body": "dmBuffer::GetCount(${1:buffer}, ${2:count})", "prefix": "dmBuffer::GetCount(buffer, count)", "description": "get buffer count."}], "ComponentTypeSetPrio(type, prio)": [{"body": "ComponentTypeSetPrio(${1:type}, ${2:prio})", "prefix": "ComponentTypeSetPrio(type, prio)", "description": "set the component type prio order"}], "Type": [{"body": "Type", "prefix": "Type", "description": "Data type"}, {"body": "Type", "prefix": "Type", "description": "Blend factor"}, {"body": "Type", "prefix": "Type", "description": "socket type"}, {"body": "Type", "prefix": "Type", "description": "token type enumeration"}], "GetStringFromHashOrString(L, index, buffer, buffer_length)": [{"body": "GetStringFromHashOrString(${1:L}, ${2:index}, ${3:buffer}, ${4:buffer_length})", "prefix": "GetStringFromHashOrString(L, index, buffer, buffer_length)", "description": "Gets as good as possible printable string from a h..."}], "DM_MUTEX_SCOPED_LOCK(mutex)": [{"body": "DM_MUTEX_SCOPED_LOCK", "prefix": "DM_MUTEX_SCOPED_LOCK(mutex)", "description": "macro for scope lifetime Mutex locking"}], "dmThread::GetCurrentThread": [{"body": "dmThread::GetCurrentThread()", "prefix": "dmThread::GetCurrentThread", "description": "gets the current thread"}], "RenderOrder": [{"body": "RenderOrder", "prefix": "RenderOrder", "description": "Render order"}], "SetBoneTransforms(instance, component_transform, transforms, transform_count)": [{"body": "SetBoneTransforms(${1:instance}, ${2:component_transform}, ${3:transforms}, ${4:transform_count})", "prefix": "SetBoneTransforms(instance, component_transform, transforms, transform_count)", "description": "Set the local transforms recursively of all instan..."}], "Key": [{"body": "Key", "prefix": "Key", "description": "keyboard key enumeration"}], "dmhash_t": [{"body": "dmhash_t", "prefix": "dmhash_t", "description": "dmhash_t type definition"}], "StencilTestParams": [{"body": "StencilTestParams", "prefix": "StencilTestParams", "description": "Struct holding stencil operation setup"}], "dmConditionVariable::HConditionVariable": [{"body": "dmConditionVariable::HConditionVariable", "prefix": "dmConditionVariable::HConditionVariable", "description": "HConditionVariable type definition"}], "Receive(socket, buffer[out], length, received_bytes[out])": [{"body": "Receive(${1:socket}, ${2:buffer[out]}, ${3:length}, ${4:received_bytes[out]})", "prefix": "Receive(socket, buffer[out], length, received_bytes[out])", "description": "Receive data on a socket"}], "PropertyResult": [{"body": "PropertyResult", "prefix": "PropertyResult", "description": "property result"}], "dmScript::PushHash(L, hash)": [{"body": "dmScript::PushHash(${1:L}, ${2:hash})", "prefix": "dmScript::PushHash(L, hash)", "description": "Push a hash value onto the supplied lua state, wil..."}], "TraverseGetRoot(regist, node)": [{"body": "TraverseGetRoot(${1:regist}, ${2:node})", "prefix": "TraverseGetRoot(regist, node)", "description": "Gets the top node of the whole game (the main coll..."}], "dmGraphics::GetNativeiOSEAGLContext": [{"body": "dmGraphics::GetNativeiOSEAGLContext()", "prefix": "dmGraphics::GetNativeiOSEAGLContext", "description": "get iOS EAGLContext"}], "dmHID::MAX_KEYBOARD_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_KEYBOARD_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_KEYBOARD_COUNT [type: uint32_t]", "description": "Maximum number of keyboards supported"}], "dmSpinlock::Init(spinlock)": [{"body": "dmSpinlock::Init(${1:spinlock})", "prefix": "dmSpinlock::Init(spinlock)", "description": "initalize spinlock."}], "dmConditionVariable::Broadcast(condition)": [{"body": "dmConditionVariable::Broadcast(${1:condition})", "prefix": "dmConditionVariable::Broadcast(condition)", "description": "broadcast condition variable"}], "dmConnectionPool::GetSocket(pool, connection)": [{"body": "dmConnectionPool::GetSocket(${1:pool}, ${2:connection})", "prefix": "dmConnectionPool::GetSocket(pool, connection)", "description": "Get socket for connection"}], "dmConnectionPool::Return(pool, connection)": [{"body": "dmConnectionPool::Return(${1:pool}, ${2:connection})", "prefix": "dmConnectionPool::Return(pool, connection)", "description": "Return connection to pool"}], "TraverseIterateChildren(node)": [{"body": "TraverseIterateChildren(${1:node})", "prefix": "TraverseIterateChildren(node)", "description": "Get a scene node iterator for the nodes' children"}], "GetWorldUniformScale(instance)": [{"body": "GetWorldUniformScale(${1:instance})", "prefix": "GetWorldUniformScale(instance)", "description": "get world uniform scale"}], "Delete(socket)": [{"body": "Delete(${1:socket})", "prefix": "Delete(socket)", "description": "delete a socket"}], "StencilOp": [{"body": "StencilOp", "prefix": "StencilOp", "description": ""}], "Touch": [{"body": "Touch", "prefix": "Touch", "description": "Data for a single touch, e.g. finger"}], "ComponentTypeSetDestroyFn(type, fn)": [{"body": "ComponentTypeSetDestroyFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetDestroyFn(type, fn)", "description": "set the component destroy callback"}], "GetWorldScale(instance)": [{"body": "GetWorldScale(${1:instance})", "prefix": "GetWorldScale(instance)", "description": "get world scale"}], "DeleteNamedConstantBuffer(buffer)": [{"body": "DeleteNamedConstantBuffer(${1:buffer})", "prefix": "DeleteNamedConstantBuffer(buffer)", "description": "Deletes a named constant buffer"}], "dmGraphics::GetNativeiOSUIView": [{"body": "dmGraphics::GetNativeiOSUIView()", "prefix": "dmGraphics::GetNativeiOSUIView", "description": "get iOS UIView"}], "GetSocketName(socket)": [{"body": "GetSocketName(${1:socket})", "prefix": "GetSocketName(socket)", "description": "Get socket name"}], "FaceWinding": [{"body": "FaceWinding", "prefix": "FaceWinding", "description": ""}], "LoadMessage(buffer, buffer_size, desc, message, options, size)": [{"body": "LoadMessage(${1:buffer}, ${2:buffer_size}, ${3:desc}, ${4:message}, ${5:options}, ${6:size})", "prefix": "LoadMessage(buffer, buffer_size, desc, message, options, size)", "description": "Load/decode a DDF message from buffer"}], "INVALID_INSTANCE_POOL_INDEX": [{"body": "INVALID_INSTANCE_POOL_INDEX()", "prefix": "INVALID_INSTANCE_POOL_INDEX", "description": "Value for an invalid instance index, this must be ..."}], "GetRenderConstant(constants, index)": [{"body": "GetRenderConstant(${1:constants}, ${2:index})", "prefix": "GetRenderConstant(constants, index)", "description": "Get a render constant by index"}], "SetConstantLocation(constant, location)": [{"body": "SetConstantLocation(${1:constant}, ${2:location})", "prefix": "SetConstantLocation(constant, location)", "description": "Sets the shader program constant location"}], "ParseHeader(header_str, user_data, end_of_receive, version_cbk, header_cbk, body_cbk)": [{"body": "ParseHeader(${1:header_str}, ${2:user_data}, ${3:end_of_receive}, ${4:version_cbk}, ${5:header_cbk}, ${6:body_cbk})", "prefix": "ParseHeader(header_str, user_data, end_of_receive, version_cbk, header_cbk, body_cbk)", "description": "parse the headers"}], "GetMouseButton(packet, button)": [{"body": "GetMouseButton(${1:packet}, ${2:button})", "prefix": "GetMouseButton(packet, button)", "description": "Convenience function to retrieve the state of a mo..."}], "dmSSLSocket::Send(socket, buffer, length, sent_bytes)": [{"body": "dmSSLSocket::Send(${1:socket}, ${2:buffer}, ${3:length}, ${4:sent_bytes})", "prefix": "dmSSLSocket::Send(socket, buffer, length, sent_bytes)", "description": "send a message on a secure socket"}], "RemoveNamedConstant(buffer, name_hash)": [{"body": "RemoveNamedConstant(${1:buffer}, ${2:name_hash})", "prefix": "RemoveNamedConstant(buffer, name_hash)", "description": "Removes a named constant from the buffer"}], "SetKey(keyboard, key, value)": [{"body": "SetKey(${1:keyboard}, ${2:key}, ${3:value})", "prefix": "SetKey(keyboard, key, value)", "description": "Sets the state of a key."}], "SceneNodeIterator": [{"body": "SceneNodeIterator", "prefix": "SceneNodeIterator", "description": "scene graph traversal iterator"}], "GetRotation": [{"body": "GetRotation()", "prefix": "GetRotation", "description": "get rotatiom"}], "RenderObject": [{"body": "RenderObject", "prefix": "RenderObject", "description": "Render objects represent an actual draw call"}], "HConstant": [{"body": "HConstant", "prefix": "HConstant", "description": "Shader constant handle"}], "SetGamepadButton(gamepad, button, value)": [{"body": "SetGamepadButton(${1:gamepad}, ${2:button}, ${3:value})", "prefix": "SetGamepadButton(gamepad, button, value)", "description": "Sets the state of a gamepad button."}], "IsIndexBufferFormatSupported(context, format, result)": [{"body": "IsIndexBufferFormatSupported(${1:context}, ${2:format}, ${3:result})", "prefix": "IsIndexBufferFormatSupported(context, format, result)", "description": "Check if the index format is supported"}], "dmBuffer::Copy(dst_buffer_handle, src_buffer_handle)": [{"body": "dmBuffer::Copy(${1:dst_buffer_handle}, ${2:src_buffer_handle})", "prefix": "dmBuffer::Copy(dst_buffer_handle, src_buffer_handle)", "description": "copy a Buffer"}], "dmCrypt::HashSha512(buf, buflen, digest)": [{"body": "dmCrypt::HashSha512(${1:buf}, ${2:buflen}, ${3:digest})", "prefix": "dmCrypt::HashSha512(buf, buflen, digest)", "description": "Hash buffer using SHA512"}], "GetIdentifier(instance)": [{"body": "GetIdentifier(${1:instance})", "prefix": "GetIdentifier(instance)", "description": "Get instance identifier"}], "GetTouchDevice(context, index)": [{"body": "GetTouchDevice(${1:context}, ${2:index})", "prefix": "GetTouchDevice(context, index)", "description": "gets a touch device handle"}], "Handler(user_data, request)": [{"body": "Handler", "prefix": "Handler(user_data, request)", "description": "Web request handler callback"}], "LoadMessageFromFile(file_name, desc, message)": [{"body": "LoadMessageFromFile(${1:file_name}, ${2:desc}, ${3:message})", "prefix": "LoadMessageFromFile(file_name, desc, message)", "description": "Load/decode a DDF message from file"}], "Get(factory, name, resource)": [{"body": "Get(${1:factory}, ${2:name}, ${3:resource})", "prefix": "Get(factory, name, resource)", "description": "Get a resource from factory"}], "GetComponentId(instance, component_index, component_id)": [{"body": "GetComponentId(${1:instance}, ${2:component_index}, ${3:component_id})", "prefix": "GetComponentId(instance, component_index, component_id)", "description": "Get component id from component index."}], "ComponentTypeSetSetPropertiesFn(type, fn)": [{"body": "ComponentTypeSetSetPropertiesFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetSetPropertiesFn(type, fn)", "description": "set the component set properties callback"}], "dmGraphics::GetNativeiOSUIWindow": [{"body": "dmGraphics::GetNativeiOSUIWindow()", "prefix": "dmGraphics::GetNativeiOSUIWindow", "description": "get iOS UIWindow"}], "HMaterial": [{"body": "HMaterial", "prefix": "HMaterial", "description": "Material instance handle"}], "SetReuseAddress(socket, reuse)": [{"body": "SetReuseAddress(${1:socket}, ${2:reuse})", "prefix": "SetReuseAddress(socket, reuse)", "description": "Set reuse socket address option on socket. Socket ..."}], "HashState32": [{"body": "HashState32", "prefix": "HashState32", "description": "Hash state used for 32-bit incremental hashing"}], "NormalizeZScale(mtx)": [{"body": "NormalizeZScale(${1:mtx})", "prefix": "NormalizeZScale(mtx)", "description": "Eliminate the z scaling components in a matrix"}], "DM_PLATFORM_ANDROID": [{"body": "DM_PLATFORM_ANDROID", "prefix": "DM_PLATFORM_ANDROID", "description": "Set if the platform is Android "}], "GetPath(url)": [{"body": "GetPath(${1:url})", "prefix": "GetPath(url)", "description": "Get the message path"}], "DeleteIndexBuffer(buffer)": [{"body": "DeleteIndexBuffer(${1:buffer})", "prefix": "DeleteIndexBuffer(buffer)", "description": "Delete the index buffer"}], "dmScript::CheckVector4(L, index)": [{"body": "dmScript::CheckVector4(${1:L}, ${2:index})", "prefix": "dmScript::CheckVector4(L, index)", "description": "check if the value is a Vectormath::Aos::Vector3"}], "CompSetConstantCallback": [{"body": "CompSetConstantCallback", "prefix": "CompSetConstantCallback", "description": "Used in SetMaterialConstant to set a render consta..."}], "ParseUrl(uri, out)": [{"body": "ParseUrl(${1:uri}, ${2:out})", "prefix": "ParseUrl(uri, out)", "description": "Convert a string to a URL struct"}], "dmHashFinal64(hash_state)": [{"body": "dmHashFinal64(${1:hash_state})", "prefix": "dmHashFinal64(hash_state)", "description": "Finalize incremental hashing and release associate..."}], "DM_DLLEXPORT": [{"body": "DM_DLLEXPORT", "prefix": "DM_DLLEXPORT", "description": "storage-class attribute for shared library export/import"}], "dmScript::LuaHBuffer": [{"body": "dmScript::LuaHBuffer", "prefix": "dmScript::LuaHBuffer", "description": "Lua wrapper for a dmBuffer::HBuffer"}], "SetMousePosition(mouse, x, y)": [{"body": "SetMousePosition(${1:mouse}, ${2:x}, ${3:y})", "prefix": "SetMousePosition(mouse, x, y)", "description": "Sets the position of a mouse."}], "HCollisionShape2D": [{"body": "HCollisionShape2D", "prefix": "HCollisionShape2D", "description": "2D collision shape handle"}], "dmHashTable16": [{"body": "dmHashTable16()", "prefix": "dmHashTable16", "description": "Specialized hash table with uint16_t as key..."}], "dmSSLSocket::Result": [{"body": "dmSSLSocket::Result", "prefix": "dmSSLSocket::Result", "description": "result enumeration"}], "SaveMessageToArray(message, desc, buffer)": [{"body": "SaveMessageToArray(${1:message}, ${2:desc}, ${3:buffer})", "prefix": "SaveMessageToArray(message, desc, buffer)", "description": "Save message to array"}], "MouseButton": [{"body": "MouseButton", "prefix": "MouseButton", "description": "mouse button enumeration"}], "dmHashClone32(hash_state, source_hash_state, reverse_hash)": [{"body": "dmHashClone32(${1:hash_state}, ${2:source_hash_state}, ${3:reverse_hash})", "prefix": "dmHashClone32(hash_state, source_hash_state, reverse_hash)", "description": "Clone 32-bit incremental hash state"}], "dmSpinlock::Unlock(spinlock)": [{"body": "dmSpinlock::Unlock(${1:spinlock})", "prefix": "dmSpinlock::Unlock(spinlock)", "description": "unlock spinlock."}], "dmSocket::SetReceiveTimeout(socket, timeout)": [{"body": "dmSocket::SetReceiveTimeout(${1:socket}, ${2:timeout})", "prefix": "dmSocket::SetReceiveTimeout(socket, timeout)", "description": "Set socket receive timeout"}], "UrlToString(url, buffer, buffer_size)": [{"body": "UrlToString(${1:url}, ${2:buffer}, ${3:buffer_size})", "prefix": "UrlToString(url, buffer, buffer_size)", "description": "Converts a URL into a readable string. Useful for ..."}], "DM_LUA_ERROR(fmt, args)": [{"body": "DM_LUA_ERROR", "prefix": "DM_LUA_ERROR(fmt, args)", "description": "helper macro to validate the Lua stack state and throw a lua error."}], "dmHashReverseSafe64(hash)": [{"body": "dmHashReverseSafe64(${1:hash})", "prefix": "dmHashReverseSafe64(hash)", "description": "get string value from hash"}], "ComponentTypeSetOnMessageFn(type, fn)": [{"body": "ComponentTypeSetOnMessageFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetOnMessageFn(type, fn)", "description": "set the component on-message callback"}], "ComponentTypeSetPropertyIteratorFn(type, fn)": [{"body": "ComponentTypeSetPropertyIteratorFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetPropertyIteratorFn(type, fn)", "description": "set the component property iterator function"}], "Pop": [{"body": "Pop()", "prefix": "Pop", "description": "array pop"}], "dmGraphics::GetNativeAndroidJavaVM": [{"body": "dmGraphics::GetNativeAndroidJavaVM()", "prefix": "dmGraphics::GetNativeAndroidJavaVM", "description": "get Android native JavaVM"}], "dmScript::IsMatrix4(L, index)": [{"body": "dmScript::IsMatrix4(${1:L}, ${2:index})", "prefix": "dmScript::IsMatrix4(L, index)", "description": "Check if the value at #index is a Vectormath::Aos:..."}], "dmCrypt::HashMd5(buf, buflen, digest)": [{"body": "dmCrypt::HashMd5(${1:buf}, ${2:buflen}, ${3:digest})", "prefix": "dmCrypt::HashMd5(buf, buflen, digest)", "description": "Hash buffer using MD5"}], "UnrefInInstance(L, ref)": [{"body": "UnrefInInstance(${1:L}, ${2:ref})", "prefix": "UnrefInInstance(L, ref)", "description": "Deletes the instance local lua reference\nExpects ..."}], "GetUniformScale": [{"body": "GetUniformScale()", "prefix": "GetUniformScale", "description": "Compute a 'uniform' scale for this transform. In t..."}], "HServer": [{"body": "HServer", "prefix": "HServer", "description": "web server handle"}], "PropertyType": [{"body": "PropertyType", "prefix": "PropertyType", "description": "property types"}], "dmExtension::CallbackType": [{"body": "dmExtension::CallbackType", "prefix": "dmExtension::CallbackType", "description": "extra callback enumeration"}], "ComponentTypeSetNewWorldFn(type, fn)": [{"body": "ComponentTypeSetNewWorldFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetNewWorldFn(type, fn)", "description": "set the new world callback"}], "ClearNamedConstantBuffer(buffer)": [{"body": "ClearNamedConstantBuffer(${1:buffer})", "prefix": "ClearNamedConstantBuffer(buffer)", "description": "Clears a named constant buffer from any constants."}], "UpdateResult": [{"body": "UpdateResult", "prefix": "UpdateResult", "description": "Update result enum"}], "dmScript::CheckHash(L, index)": [{"body": "dmScript::CheckHash(${1:L}, ${2:index})", "prefix": "dmScript::CheckHash(L, index)", "description": "get hash value"}], "SetReceiveTimeout(socket, timeout)": [{"body": "SetReceiveTimeout(${1:socket}, ${2:timeout})", "prefix": "SetReceiveTimeout(socket, timeout)", "description": "Set socket receive timeout"}], "dmScript::PushMatrix4(L, matrix)": [{"body": "dmScript::PushMatrix4(${1:L}, ${2:matrix})", "prefix": "dmScript::PushMatrix4(L, matrix)", "description": "push a Vectormath::Aos::Matrix4 onto the Lua stack"}], "GetMaxElementsIndices(context)": [{"body": "GetMaxElementsIndices(${1:context})", "prefix": "GetMaxElementsIndices(context)", "description": "Get the max number of indices allowed by the syste..."}], "PrimitiveType": [{"body": "PrimitiveType", "prefix": "PrimitiveType", "description": "Primitive type"}], "GetConstantName(constant, name)": [{"body": "GetConstantName(${1:constant}, ${2:name})", "prefix": "GetConstantName(constant, name)", "description": "Gets the shader program constant name"}], "InputAction": [{"body": "InputAction", "prefix": "InputAction", "description": "Container of input related information."}], "GetNamedConstant(buffer, name_hash, values, num_values)": [{"body": "GetNamedConstant(${1:buffer}, ${2:name_hash}, ${3:values}, ${4:num_values})", "prefix": "GetNamedConstant(buffer, name_hash, values, num_values)", "description": "Gets a named constant from the buffer"}], "Document": [{"body": "Document", "prefix": "Document", "description": "Json document"}], "dmMessage::Result": [{"body": "dmMessage::Result", "prefix": "dmMessage::Result", "description": "Result enum"}], "GetMousePacket(mouse, out_packet)": [{"body": "GetMousePacket(${1:mouse}, ${2:out_packet})", "prefix": "GetMousePacket(mouse, out_packet)", "description": "Obtain a mouse packet reflecting the current input..."}], "ThreadAttacher": [{"body": "ThreadAttacher", "prefix": "ThreadAttacher", "description": "Struct attaching the JNI environment. Detaches the"}, {"body": "ThreadAttacher()", "prefix": "ThreadAttacher", "description": "constructor"}], "IndexBufferFormat": [{"body": "IndexBufferFormat", "prefix": "IndexBufferFormat", "description": ""}], "SceneNodeProperty": [{"body": "SceneNodeProperty", "prefix": "SceneNodeProperty", "description": "scene traversal node property"}], "dmConnectionPool::Shutdown(pool, how)": [{"body": "dmConnectionPool::Shutdown(${1:pool}, ${2:how})", "prefix": "dmConnectionPool::Shutdown(pool, how)", "description": "Shuts down all open sockets in the pool and block ..."}], "dmHID::HMouse": [{"body": "dmHID::HMouse", "prefix": "dmHID::HMouse", "description": "mouse context handle"}], "dmThread::SetThreadName(thread, name)": [{"body": "dmThread::SetThreadName(${1:thread}, ${2:name})", "prefix": "dmThread::SetThreadName(thread, name)", "description": "sets the current thread name"}], "SetScale": [{"body": "SetScale()", "prefix": "SetScale", "description": "set scale"}], "dmScript::ToVector3(L, index)": [{"body": "dmScript::ToVector3(${1:L}, ${2:index})", "prefix": "dmScript::ToVector3(L, index)", "description": "get the value at index as a Vectormath::Aos::Vector3*"}], "dmStrTok(string, delim, lasts)": [{"body": "dmStrTok(${1:string}, ${2:delim}, ${3:lasts})", "prefix": "dmStrTok(string, delim, lasts)", "description": "Tokenize strings."}], "GetTranslation": [{"body": "GetTranslation()", "prefix": "GetTranslation", "description": "get translation"}], "LuaBufferOwnership": [{"body": "LuaBufferOwnership", "prefix": "LuaBufferOwnership", "description": "buffer ownership"}], "HScript": [{"body": "HScript", "prefix": "HScript", "description": "Script handle"}], "dmMutex::New": [{"body": "dmMutex::New()", "prefix": "dmMutex::New", "description": "create Mutex"}], "dmThread::Join(thread)": [{"body": "dmThread::Join(${1:thread})", "prefix": "dmThread::Join(thread)", "description": "join thread"}], "SetVertexBufferSubData(buffer, offset, size, data)": [{"body": "SetVertexBufferSubData(${1:buffer}, ${2:offset}, ${3:size}, ${4:data})", "prefix": "SetVertexBufferSubData(buffer, offset, size, data)", "description": "Set subset of vertex buffer data"}], "HashState64": [{"body": "HashState64", "prefix": "HashState64", "description": "Hash state used for 64-bit incremental hashing"}], "EraseSwap(index)": [{"body": "EraseSwap(${1:index})", "prefix": "EraseSwap(index)", "description": "array eraseswap"}], "dmBuffer::StreamDeclaration": [{"body": "dmBuffer::StreamDeclaration", "prefix": "dmBuffer::StreamDeclaration", "description": "StreamDeclaration struct"}], "dmScript::IsVector3(L, index)": [{"body": "dmScript::IsVector3(${1:L}, ${2:index})", "prefix": "dmScript::IsVector3(L, index)", "description": "Check if the value at #index is a Vectormath::Aos:..."}], "Send(socket, buffer, length, sent_bytes[out])": [{"body": "Send(${1:socket}, ${2:buffer}, ${3:length}, ${4:sent_bytes[out]})", "prefix": "Send(socket, buffer, length, sent_bytes[out])", "description": "Send a message on a socket"}], "SetBroadcast(socket, broadcast)": [{"body": "SetBroadcast(${1:socket}, ${2:broadcast})", "prefix": "SetBroadcast(socket, broadcast)", "description": "Set broadcast address option on socket. Socket opt..."}], "ComponentTypeSetContext(type, context)": [{"body": "ComponentTypeSetContext(${1:type}, ${2:context})", "prefix": "ComponentTypeSetContext(type, context)", "description": "set the component type global context"}], "OffsetCapacity(offset)": [{"body": "OffsetCapacity(${1:offset})", "prefix": "OffsetCapacity(offset)", "description": "array offset capacity"}], "dmRender::GetMaterialVertexSpace(material)": [{"body": "dmRender::GetMaterialVertexSpace(${1:material})", "prefix": "dmRender::GetMaterialVertexSpace(material)", "description": "Get the vertex space (local or world)"}], "SResourceDescriptor": [{"body": "SResourceDescriptor()", "prefix": "SResourceDescriptor", "description": "Resource descriptor"}], "Swap(rhs)": [{"body": "Swap(${1:rhs})", "prefix": "Swap(rhs)", "description": "array swap"}], "SetTranslation(translation)": [{"body": "SetTranslation(${1:translation})", "prefix": "SetTranslation(translation)", "description": "set translation"}], "dmConnectionPool::Dial(pool, host, port, ssl, timeout, cancelflag, connection, sock_res)": [{"body": "dmConnectionPool::Dial(${1:pool}, ${2:host}, ${3:port}, ${4:ssl}, ${5:timeout}, ${6:cancelflag}, ${7:connection}, ${8:sock_res})", "prefix": "dmConnectionPool::Dial(pool, host, port, ssl, timeout, cancelflag, connection, sock_res)", "description": "Connection to a host/port"}], "SetBone(instance, bone)": [{"body": "SetBone(${1:instance}, ${2:bone})", "prefix": "SetBone(instance, bone)", "description": "Set whether the instance should be flagged as a bo..."}], "dmScript::ToVector4(L, index)": [{"body": "dmScript::ToVector4(${1:L}, ${2:index})", "prefix": "dmScript::ToVector4(L, index)", "description": "get the value at index as a Vectormath::Aos::Vector4*"}], "dmCrypt::Base64Decode(src, src_len, dst, dst_len[in,out])": [{"body": "dmCrypt::Base64Decode(${1:src}, ${2:src_len}, ${3:dst}, ${4:dst_len[in,out]})", "prefix": "dmCrypt::Base64Decode(src, src_len, dst, dst_len[in,out])", "description": "Base64 decode a buffer"}], "DM_PLATFORM_WINDOWS": [{"body": "DM_PLATFORM_WINDOWS", "prefix": "DM_PLATFORM_WINDOWS", "description": "Set if the platform is Windows  (on both x86 and x86_64)"}], "GetFragment(url)": [{"body": "GetFragment(${1:url})", "prefix": "GetFragment(url)", "description": "Get the message fragment"}], "ComponentTypeSetGetFn(type, fn)": [{"body": "ComponentTypeSetGetFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetGetFn(type, fn)", "description": "set the component get callback"}], "dmHID::HContext": [{"body": "dmHID::HContext", "prefix": "dmHID::HContext", "description": "HID context handle"}], "DM_LUA_STACK_CHECK(L, diff)": [{"body": "DM_LUA_STACK_CHECK", "prefix": "DM_LUA_STACK_CHECK(L, diff)", "description": "helper macro to validate the Lua stack state before leaving a function."}], "dmLogFatal(format, args)": [{"body": "dmLogFatal(${1:format}, ${2:args})", "prefix": "dmLogFatal(format, args)", "description": "log with \"fatal\" severity"}], "VertexElement": [{"body": "VertexElement", "prefix": "VertexElement", "description": ""}], "dmScript::GetCallbackLuaContext(cbk)": [{"body": "dmScript::GetCallbackLuaContext(${1:cbk})", "prefix": "dmScript::GetCallbackLuaContext(cbk)", "description": "Gets the Lua context from a callback struct"}], "DM_PLATFORM_HTML5": [{"body": "DM_PLATFORM_HTML5", "prefix": "DM_PLATFORM_HTML5", "description": "Set if the platform is Html5 "}], "NewVertexBuffer(context, size, data, buffer_usage)": [{"body": "NewVertexBuffer(${1:context}, ${2:size}, ${3:data}, ${4:buffer_usage})", "prefix": "NewVertexBuffer(context, size, data, buffer_usage)", "description": "Create new vertex buffer with initial data"}], "GetRenderConstant(constants, name_hash, out_constant)": [{"body": "GetRenderConstant(${1:constants}, ${2:name_hash}, ${3:out_constant})", "prefix": "GetRenderConstant(constants, name_hash, out_constant)", "description": "Destroys a render constants container"}], "DM_DECLARE_EXTENSION(symbol, name, appinit, appfinal, init, update, on_event, final)": [{"body": "DM_DECLARE_EXTENSION", "prefix": "DM_DECLARE_EXTENSION(symbol, name, appinit, appfinal, init, update, on_event, final)", "description": "declare a new extension"}], "Push(element)": [{"body": "Push(${1:element})", "prefix": "Push(element)", "description": "array push"}], "CompGetConstantCallback": [{"body": "CompGetConstantCallback", "prefix": "CompGetConstantCallback", "description": "Used in GetMaterialConstant to resolve a render co..."}], "GetWorldTransform(instance)": [{"body": "GetWorldTransform(${1:instance})", "prefix": "GetWorldTransform(instance)", "description": "get world transform"}], "Selector": [{"body": "Selector", "prefix": "Selector", "description": "Selector"}], "SetNoDelay(socket, no_delay)": [{"body": "SetNoDelay(${1:socket}, ${2:no_delay})", "prefix": "SetNoDelay(socket, no_delay)", "description": "Set TCP_NODELAY on socket"}], "dmMMessage::MessageDestroyCallback": [{"body": "dmMMessage::MessageDestroyCallback", "prefix": "dmMMessage::MessageDestroyCallback", "description": "A callback for messages that needs cleanup after b..."}], "BufferAccess": [{"body": "BufferAccess", "prefix": "BufferAccess", "description": ""}], "Shutdown(socket, how)": [{"body": "Shutdown(${1:socket}, ${2:how})", "prefix": "Shutdown(socket, how)", "description": "close socket"}], "SetNamedConstant(buffer, name_hash, values, num_values)": [{"body": "SetNamedConstant(${1:buffer}, ${2:name_hash}, ${3:values}, ${4:num_values})", "prefix": "SetNamedConstant(buffer, name_hash, values, num_values)", "description": "Sets a named constant to the buffer"}], "SetConstantType(constant, type)": [{"body": "SetConstantType(${1:constant}, ${2:type})", "prefix": "SetConstantType(constant, type)", "description": "Sets the type of the constant"}], "TraverseIterateProperties(node)": [{"body": "TraverseIterateProperties(${1:node})", "prefix": "TraverseIterateProperties(node)", "description": "Create a scene node traversal property iterator"}], "UnregisteriOSUIApplicationDelegate(delegate)": [{"body": "UnregisteriOSUIApplicationDelegate(${1:delegate})", "prefix": "UnregisteriOSUIApplicationDelegate(delegate)", "description": "Unregister an application delegate"}], "EnableRenderObjectConstants(ro, constants)": [{"body": "EnableRenderObjectConstants(${1:ro}, ${2:constants})", "prefix": "EnableRenderObjectConstants(ro, constants)", "description": "set the constants of a render object"}], "dmURI::Parse(uri, parts)": [{"body": "dmURI::Parse(${1:uri}, ${2:parts})", "prefix": "dmURI::Parse(uri, parts)", "description": "Parse URI and split in three parts. (scheme, locat..."}], "dmBuffer::ValidateBuffer(buffer)": [{"body": "dmBuffer::ValidateBuffer(${1:buffer})", "prefix": "dmBuffer::ValidateBuffer(buffer)", "description": "validate buffer."}], "dmHID::INVALID_MOUSE_HANDLE [type: dmHID::HMouse]": [{"body": "dmHID::INVALID_MOUSE_HANDLE [type: dmHID::HMouse]()", "prefix": "dmHID::INVALID_MOUSE_HANDLE [type: dmHID::HMouse]", "description": "invalid mouse handle"}], "dmLogDebug(format, args)": [{"body": "dmLogDebug(${1:format}, ${2:args})", "prefix": "dmLogDebug(format, args)", "description": "log with \"debug\" severity"}], "DeleteBones(parent)": [{"body": "DeleteBones(${1:parent})", "prefix": "DeleteBones(parent)", "description": "Recursively delete all instances flagged as bones ..."}], "dmBuffer::GetResultString(result)": [{"body": "dmBuffer::GetResultString(${1:result})", "prefix": "dmBuffer::GetResultString(result)", "description": "result to string"}], "CompareFunc": [{"body": "CompareFunc", "prefix": "CompareFunc", "description": ""}], "NewIndexBuffer(context, size, data, buffer_usage)": [{"body": "NewIndexBuffer(${1:context}, ${2:size}, ${3:data}, ${4:buffer_usage})", "prefix": "NewIndexBuffer(context, size, data, buffer_usage)", "description": "Create new index buffer with initial data"}], "Delete(collection, instance, recursive)": [{"body": "Delete(${1:collection}, ${2:instance}, ${3:recursive})", "prefix": "Delete(collection, instance, recursive)", "description": "Delete gameobject instance"}], "Result": [{"body": "Result", "prefix": "Result", "description": "result codes"}, {"body": "Result", "prefix": "Result", "description": "result enumeration"}, {"body": "Result", "prefix": "Result", "description": ""}, {"body": "Result", "prefix": "Result", "description": "socket result"}, {"body": "Result", "prefix": "Result", "description": "result enumeration"}, {"body": "Result", "prefix": "Result", "description": "result enumeration"}, {"body": "Result", "prefix": "Result", "description": "result enumeration"}], "SetMouseButton(mouse, button, value)": [{"body": "SetMouseButton(${1:mouse}, ${2:button}, ${3:value})", "prefix": "SetMouseButton(mouse, button, value)", "description": "Sets the state of a mouse button."}], "dmURI::Encode(src, dst, dst_size, bytes_written[out])": [{"body": "dmURI::Encode(${1:src}, ${2:dst}, ${3:dst_size}, ${4:bytes_written[out]})", "prefix": "dmURI::Encode(src, dst, dst_size, bytes_written[out])", "description": "Performs URL encoding of the supplied buffer"}], "GetConstantName(constant)": [{"body": "GetConstantName(${1:constant})", "prefix": "GetConstantName(constant)", "description": "Gets the shader program constant name"}], "DM_SPINLOCK_SCOPED_LOCK(mutex)": [{"body": "DM_SPINLOCK_SCOPED_LOCK", "prefix": "DM_SPINLOCK_SCOPED_LOCK(mutex)", "description": "macro for using a spinlock during a scope"}], "DM_RELEASE": [{"body": "DM_RELEASE", "prefix": "DM_RELEASE", "description": "define for release builds"}], "Transform": [{"body": "Transform", "prefix": "Transform", "description": "Transform with non-uniform (3-component) scale"}, {"body": "Transform()", "prefix": "Transform", "description": "Constructor. Leaves the struct in an uninitialized..."}], "dmScript::CheckQuat(L, index)": [{"body": "dmScript::CheckQuat(${1:L}, ${2:index})", "prefix": "dmScript::CheckQuat(L, index)", "description": "check if the value is a Vectormath::Aos::Vector3"}], "dmHID::HTouchDevice": [{"body": "dmHID::HTouchDevice", "prefix": "dmHID::HTouchDevice", "description": "touch device context handle"}], "dmURI::Parts": [{"body": "dmURI::Parts", "prefix": "dmURI::Parts", "description": "URI parsing result parts"}], "SetCapacity(capacity)": [{"body": "SetCapacity(${1:capacity})", "prefix": "SetCapacity(capacity)", "description": "array set capacity"}], "HFontMap": [{"body": "HFontMap", "prefix": "HFontMap", "description": "Font map handle"}], "DestroyRenderConstants(constants)": [{"body": "DestroyRenderConstants(${1:constants})", "prefix": "DestroyRenderConstants(constants)", "description": "Destroys a render constants container"}], "SetQuickAck(socket, use_quick_ack)": [{"body": "SetQuickAck(${1:socket}, ${2:use_quick_ack})", "prefix": "SetQuickAck(socket, use_quick_ack)", "description": "Set TCP_QUICKACK on socket"}], "dmBuffer::GetStreamType(buffer, stream_name, type, components)": [{"body": "dmBuffer::GetStreamType(${1:buffer}, ${2:stream_name}, ${3:type}, ${4:components})", "prefix": "dmBuffer::GetStreamType(buffer, stream_name, type, components)", "description": "get stream type and type count"}], "dmConnectionPool::Params": [{"body": "dmConnectionPool::Params", "prefix": "dmConnectionPool::Params", "description": "Creation parameters"}], "dmSSLSocket::Receive(socket, buffer, length, received_bytes)": [{"body": "dmSSLSocket::Receive(${1:socket}, ${2:buffer}, ${3:length}, ${4:received_bytes})", "prefix": "dmSSLSocket::Receive(socket, buffer, length, received_bytes)", "description": "receive data on a secure socket"}], "GetRotation(instance)": [{"body": "GetRotation(${1:instance})", "prefix": "GetRotation(instance)", "description": "get rotation"}], "ComponentTypeSetAddToUpdateFn(type, fn)": [{"body": "ComponentTypeSetAddToUpdateFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetAddToUpdateFn(type, fn)", "description": "set the component add-to-update callback"}], "dmExtension::AppParams": [{"body": "dmExtension::AppParams", "prefix": "dmExtension::AppParams", "description": "application level callback data"}], "GetHostByName(name, address, ipv4, ipv6)": [{"body": "GetHostByName(${1:name}, ${2:address}, ${3:ipv4}, ${4:ipv6})", "prefix": "GetHostByName(name, address, ipv4, ipv6)", "description": "get host by name"}], "dmJson::Type(L, doc, index, error_str_out, error_str_size)": [{"body": "dmJson::Type(${1:L}, ${2:doc}, ${3:index}, ${4:error_str_out}, ${5:error_str_size})", "prefix": "dmJson::Type(L, doc, index, error_str_out, error_str_size)", "description": "convert a dmJson::Document to a Lua table"}], "GetConstantValues(constant, num_values)": [{"body": "GetConstantValues(${1:constant}, ${2:num_values})", "prefix": "GetConstantValues(constant, num_values)", "description": "Gets the shader program constant values"}], "InputResult": [{"body": "InputResult", "prefix": "InputResult", "description": "Input result enum"}], "HRenderContext": [{"body": "HRenderContext", "prefix": "HRenderContext", "description": "The render context"}], "SetScale(instance, scale)": [{"body": "SetScale(${1:instance}, ${2:scale})", "prefix": "SetScale(instance, scale)", "description": "set uniform scale"}, {"body": "SetScale(${1:instance}, ${2:scale})", "prefix": "SetScale(instance, scale)", "description": "set scale"}], "dmThread::AllocTls": [{"body": "dmThread::AllocTls()", "prefix": "dmThread::AllocTls", "description": "allocate thread local storage key"}], "dmScript::PushQuat(L, quat)": [{"body": "dmScript::PushQuat(${1:L}, ${2:quat})", "prefix": "dmScript::PushQuat(L, quat)", "description": "push a Vectormath::Aos::Quat onto the Lua stack"}], "RegisteriOSUIApplicationDelegate(delegate)": [{"body": "RegisteriOSUIApplicationDelegate(${1:delegate})", "prefix": "RegisteriOSUIApplicationDelegate(delegate)", "description": "Register application delegate"}], "SetPosition(instance, position)": [{"body": "SetPosition(${1:instance}, ${2:position})", "prefix": "SetPosition(instance, position)", "description": "set position"}], "dmMessage::StringURL": [{"body": "dmMessage::StringURL", "prefix": "dmMessage::StringURL", "description": "Helper struct for parsing a string of the form \"so..."}], "Size": [{"body": "Size()", "prefix": "Size", "description": "size of array"}], "SetRotation(instance, position)": [{"body": "SetRotation(${1:instance}, ${2:position})", "prefix": "SetRotation(instance, position)", "description": "set rotation"}], "DM_ALIGN(x, a)": [{"body": "DM_ALIGN", "prefix": "DM_ALIGN(x, a)", "description": "value alignment macro"}], "AddTouch(device, x, y, id, phase)": [{"body": "AddTouch(${1:device}, ${2:x}, ${3:y}, ${4:id}, ${5:phase})", "prefix": "AddTouch(device, x, y, id, phase)", "description": "Adds a touch event touch."}], "GamepadPacket": [{"body": "GamepadPacket", "prefix": "GamepadPacket", "description": "Contains the current state of a gamepad"}], "dmHashBuffer32(buffer, buffer_len)": [{"body": "dmHashBuffer32(${1:buffer}, ${2:buffer_len})", "prefix": "dmHashBuffer32(buffer, buffer_len)", "description": "Calculate 32-bit hash value from buffer"}], "GetConstantType(constant)": [{"body": "GetConstantType(${1:constant})", "prefix": "GetConstantType(constant)", "description": "Gets the type of the constant"}], "GetScale(instance)": [{"body": "GetScale(${1:instance})", "prefix": "GetScale(instance)", "description": "get scale"}], "RenderListEntry(m_WorldPosition, m_Order, m_BatchKey, m_TagListKey, m_UserData, m_MinorOrder, m_MajorOrder, m_Dispatch)": [{"body": "RenderListEntry(${1:m_WorldPosition}, ${2:m_Order}, ${3:m_BatchKey}, ${4:m_TagListKey}, ${5:m_UserData}, ${6:m_MinorOrder}, ${7:m_MajorOrder}, ${8:m_Dispatch})", "prefix": "RenderListEntry(m_WorldPosition, m_Order, m_BatchKey, m_TagListKey, m_UserData, m_MinorOrder, m_MajorOrder, m_Dispatch)", "description": "Represents a renderable object (e.g. a single spri..."}], "Back": [{"body": "Back()", "prefix": "Back", "description": "array back"}, {"body": "Back()", "prefix": "Back", "description": "array back (const)"}], "HPrototype": [{"body": "HPrototype", "prefix": "HPrototype", "description": "Gameobject prototype handle"}], "NewConstant(name_hash)": [{"body": "NewConstant(${1:name_hash})", "prefix": "NewConstant(name_hash)", "description": "Creates a shader program constant"}], "ShutdownType": [{"body": "ShutdownType", "prefix": "ShutdownType", "description": "socket shutdown type"}], "SelectorSet(selector, selector_kind, socket)": [{"body": "SelectorSet(${1:selector}, ${2:selector_kind}, ${3:socket})", "prefix": "SelectorSet(selector, selector_kind, socket)", "description": "Set selector for socket. Similar to FD_SET"}], "dmHID::MAX_GAMEPAD_HAT_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_GAMEPAD_HAT_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_GAMEPAD_HAT_COUNT [type: uint32_t]", "description": "Maximum number of gamepad hats supported"}], "SetIndexBufferData(buffer, size, data, buffer_usage)": [{"body": "SetIndexBufferData(${1:buffer}, ${2:size}, ${3:data}, ${4:buffer_usage})", "prefix": "SetIndexBufferData(buffer, size, data, buffer_usage)", "description": "Set index buffer data"}], "dmScript::IsBuffer(L, index)": [{"body": "dmScript::IsBuffer(${1:L}, ${2:index})", "prefix": "dmScript::IsBuffer(L, index)", "description": "check if the value is a dmScript::LuaHBuffer"}], "DeleteVertexDeclaration(vertex_declaration)": [{"body": "DeleteVertexDeclaration(${1:vertex_declaration})", "prefix": "DeleteVertexDeclaration(vertex_declaration)", "description": "Delete vertex declaration"}], "ComponentTypeSetSetPropertyFn(type, fn)": [{"body": "ComponentTypeSetSetPropertyFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetSetPropertyFn(type, fn)", "description": "set the component set property callback"}], "SetGamepadAxis(gamepad, axis, value)": [{"body": "SetGamepadAxis(${1:gamepad}, ${2:axis}, ${3:value})", "prefix": "SetGamepadAxis(gamepad, axis, value)", "description": "Sets the state of a gamepad axis."}], "GetWorldMatrix(instance)": [{"body": "GetWorldMatrix(${1:instance})", "prefix": "GetWorldMatrix(instance)", "description": "get world matrix"}], "dmGraphics::GetNativeAndroidEGLSurface": [{"body": "dmGraphics::GetNativeAndroidEGLSurface()", "prefix": "dmGraphics::GetNativeAndroidEGLSurface", "description": "get Android EGLSurface"}], "dmHID::INVALID_GAMEPAD_HANDLE [type: dmHID::HGamepad]": [{"body": "dmHID::INVALID_GAMEPAD_HANDLE [type: dmHID::HGamepad]()", "prefix": "dmHID::INVALID_GAMEPAD_HANDLE [type: dmHID::HGamepad]", "description": "invalid gamepad handle"}], "Address": [{"body": "Address", "prefix": "Address", "description": "network address"}], "dmLogError(format, args)": [{"body": "dmLogError(${1:format}, ${2:args})", "prefix": "dmLogError(format, args)", "description": "log with \"error\" severity"}], "Detach": [{"body": "Detach()", "prefix": "Detach", "description": "Detaches the jni environment"}], "dmBuffer::GetContentVersion(type, version)": [{"body": "dmBuffer::GetContentVersion(${1:type}, ${2:version})", "prefix": "dmBuffer::GetContentVersion(type, version)", "description": "Gets the current update number"}], "RegisterCallback(callback_type, func)": [{"body": "RegisterCallback(${1:callback_type}, ${2:func})", "prefix": "RegisterCallback(callback_type, func)", "description": "Register extra extension callbacks."}], "TraverseIteratePropertiesNext(it)": [{"body": "TraverseIteratePropertiesNext(${1:it})", "prefix": "TraverseIteratePropertiesNext(it)", "description": "Steps the scene node traversal property iterator t..."}], "dmConditionVariable::New": [{"body": "dmConditionVariable::New()", "prefix": "dmConditionVariable::New", "description": "create condition variable"}], "GetUniformScale(instance)": [{"body": "GetUniformScale(${1:instance})", "prefix": "GetUniformScale(instance)", "description": "get uniform scale"}], "GetEnv": [{"body": "GetEnv()", "prefix": "GetEnv", "description": "Gets the JNI environment"}], "New(collection, prototype_name)": [{"body": "New(${1:collection}, ${2:prototype_name})", "prefix": "New(collection, prototype_name)", "description": "Create a new gameobject instance"}], "SceneNodePropertyType": [{"body": "SceneNodePropertyType", "prefix": "SceneNodePropertyType", "description": "scene node property types"}], "SelectorZero(selector)": [{"body": "SelectorZero(${1:selector})", "prefix": "SelectorZero(selector)", "description": "Clear selector (all kinds). Similar to FD_ZERO"}], "NormalizeZScale(source, target)": [{"body": "NormalizeZScale(${1:source}, ${2:target})", "prefix": "NormalizeZScale(source, target)", "description": "Eliminate the z scaling components in a matrix"}], "ApplyNoScaleZ(t, v)": [{"body": "ApplyNoScaleZ(${1:t}, ${2:v})", "prefix": "ApplyNoScaleZ(t, v)", "description": "Apply the transform on a vector, but without scali..."}], "ComponentTypeSetOnReloadFn(type, fn)": [{"body": "ComponentTypeSetOnReloadFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetOnReloadFn(type, fn)", "description": "set the component on-reload callback"}], "dmConnectionPool::Delete(pool)": [{"body": "dmConnectionPool::Delete(${1:pool})", "prefix": "dmConnectionPool::Delete(pool)", "description": "Delete connnection pool"}], "GetConfigFile(app_params)": [{"body": "GetConfigFile(${1:app_params})", "prefix": "GetConfigFile(app_params)", "description": "get the config file"}], "HFragmentProgram": [{"body": "HFragmentProgram", "prefix": "HFragmentProgram", "description": "Fragment program handle"}], "KeyboardPacket": [{"body": "KeyboardPacket", "prefix": "KeyboardPacket", "description": "Contains the current state of a keyboard"}], "GetWorldRotation(instance)": [{"body": "GetWorldRotation(${1:instance})", "prefix": "GetWorldRotation(instance)", "description": "get world rotation"}], "GetDescriptorFromHash(hash)": [{"body": "GetDescriptorFromHash(${1:hash})", "prefix": "GetDescriptorFromHash(hash)", "description": "Get Descriptor from hash name"}], "dmScript::LuaCallbackInfo": [{"body": "dmScript::LuaCallbackInfo", "prefix": "dmScript::LuaCallbackInfo", "description": "callback info struct"}], "ResetUrl(url)": [{"body": "ResetUrl(${1:url})", "prefix": "ResetUrl(url)", "description": "Resets the given URL to default values."}], "dmGraphics::GetNativeAndroidApp": [{"body": "dmGraphics::GetNativeAndroidApp()", "prefix": "dmGraphics::GetNativeAndroidApp", "description": "get Android app object"}], "SelectorClear(selector, selector_kind, socket)": [{"body": "SelectorClear(${1:selector}, ${2:selector_kind}, ${3:socket})", "prefix": "SelectorClear(selector, selector_kind, socket)", "description": "Clear selector for socket. Similar to FD_CLR"}], "DeleteVertexBuffer(buffer)": [{"body": "DeleteVertexBuffer(${1:buffer})", "prefix": "DeleteVertexBuffer(buffer)", "description": "Delete vertex buffer"}], "GetMaterialTagListKey(material)": [{"body": "GetMaterialTagListKey(${1:material})", "prefix": "GetMaterialTagListKey(material)", "description": "Gets the key to the material tag list"}], "ComponentTypeSetPostUpdateFn(type, fn)": [{"body": "ComponentTypeSetPostUpdateFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetPostUpdateFn(type, fn)", "description": "set the component post update callback"}], "dmConfigFile::GetFloat(config, key, default_value)": [{"body": "dmConfigFile::GetFloat(${1:config}, ${2:key}, ${3:default_value})", "prefix": "dmConfigFile::GetFloat(config, key, default_value)", "description": "get config value as float"}], "Remaining": [{"body": "Remaining()", "prefix": "Remaining", "description": "remaining size of array"}], "dmHashString64(string)": [{"body": "dmHashString64(${1:string})", "prefix": "dmHashString64(string)", "description": "calculate 64-bit hash value from string"}], "ComponentTypeSetRenderFn(type, fn)": [{"body": "ComponentTypeSetRenderFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetRenderFn(type, fn)", "description": "set the component render callback"}], "dmLogInfo(format, args)": [{"body": "dmLogInfo(${1:format}, ${2:args})", "prefix": "dmLogInfo(format, args)", "description": "log with \"info\" severity"}], "HRegister": [{"body": "HRegister", "prefix": "HRegister", "description": "Collection register."}], "dmHashUpdateBuffer32(hash_state, buffer, buffer_len)": [{"body": "dmHashUpdateBuffer32(${1:hash_state}, ${2:buffer}, ${3:buffer_len})", "prefix": "dmHashUpdateBuffer32(hash_state, buffer, buffer_len)", "description": "Incremental hashing"}], "Front": [{"body": "Front()", "prefix": "Front", "description": "array front"}, {"body": "Front()", "prefix": "Front", "description": "array front (const)"}], "HTexture": [{"body": "HTexture", "prefix": "HTexture", "description": "Texture handle"}], "GetSocket(url)": [{"body": "GetSocket(${1:url})", "prefix": "GetSocket(url)", "description": "Get the message socket"}], "dmHID::MAX_MOUSE_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_MOUSE_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_MOUSE_COUNT [type: uint32_t]", "description": "Maximum number of mice supported"}], "dmArray(user_array, size, capacity)": [{"body": "dmArray(${1:user_array}, ${2:size}, ${3:capacity})", "prefix": "dmArray(user_array, size, capacity)", "description": "constructor. user-allocated memory"}], "SetNamedConstants(buffer, constants, num_constants)": [{"body": "SetNamedConstants(${1:buffer}, ${2:constants}, ${3:num_constants})", "prefix": "SetNamedConstants(buffer, constants, num_constants)", "description": "Sets a list of named constants to the buffer"}], "dmScript::ToQuat(L, index)": [{"body": "dmScript::ToQuat(${1:L}, ${2:index})", "prefix": "dmScript::ToQuat(L, index)", "description": "get the value at index as a Vectormath::Aos::Quat*"}], "dmGraphics::GetNativeAndroidActivity": [{"body": "dmGraphics::GetNativeAndroidActivity()", "prefix": "dmGraphics::GetNativeAndroidActivity", "description": "get Android native jobject"}], "HProperties": [{"body": "HProperties", "prefix": "HProperties", "description": "Gameobject properties handle"}], "HNamedConstantBuffer": [{"body": "HNamedConstantBuffer", "prefix": "HNamedConstantBuffer", "description": "Shader constant buffer handle. Holds name and valu..."}], "dmStrlCpy(dst, src, size)": [{"body": "dmStrlCpy(${1:dst}, ${2:src}, ${3:size})", "prefix": "dmStrlCpy(dst, src, size)", "description": "Size-bounded string copying."}], "ComponentTypeSetReadsTransforms(type, reads_transforms)": [{"body": "ComponentTypeSetReadsTransforms(${1:type}, ${2:reads_transforms})", "prefix": "ComponentTypeSetReadsTransforms(type, reads_transforms)", "description": "set the component type transform dependency flag"}], "dmScript::SetupCallback(cbk)": [{"body": "dmScript::SetupCallback(${1:cbk})", "prefix": "dmScript::SetupCallback(cbk)", "description": "Setups up the Lua callback prior to a call to dmScript::PCall()"}], "GetNamedConstantCount(buffer)": [{"body": "GetNamedConstantCount(${1:buffer})", "prefix": "GetNamedConstantCount(buffer)", "description": "Gets number of constants in the buffer"}], "dmHID::MAX_CHAR_COUNT": [{"body": "dmHID::MAX_CHAR_COUNT()", "prefix": "dmHID::MAX_CHAR_COUNT", "description": "max number of characters"}], "dmScript::PostDDF(message, sender, receiver, function_ref, unref_function_after_call)": [{"body": "dmScript::PostDDF(${1:message}, ${2:sender}, ${3:receiver}, ${4:function_ref}, ${5:unref_function_after_call})", "prefix": "dmScript::PostDDF(message, sender, receiver, function_ref, unref_function_after_call)", "description": "Sends a script message"}], "SetRenderConstant(constants, name_hash, values, num_values)": [{"body": "SetRenderConstant(${1:constants}, ${2:name_hash}, ${3:values}, ${4:num_values})", "prefix": "SetRenderConstant(constants, name_hash, values, num_values)", "description": "Set a render constant by name. The constant must e..."}], "DM_PLATFORM_LINUX": [{"body": "DM_PLATFORM_LINUX", "prefix": "DM_PLATFORM_LINUX", "description": "Set if the platform is Linux "}], "SetRenderConstant(constants, material, name_hash, value_index, element_index, var)": [{"body": "SetRenderConstant(${1:constants}, ${2:material}, ${3:name_hash}, ${4:value_index}, ${5:element_index}, ${6:var})", "prefix": "SetRenderConstant(constants, material, name_hash, value_index, element_index, var)", "description": "Set a render constant by name. The constant must e..."}], "SetStatusCode(request, status_code)": [{"body": "SetStatusCode(${1:request}, ${2:status_code})", "prefix": "SetStatusCode(request, status_code)", "description": "Set response status code."}], "dmConditionVariable::Wait(condition, mutex)": [{"body": "dmConditionVariable::Wait(${1:condition}, ${2:mutex})", "prefix": "dmConditionVariable::Wait(condition, mutex)", "description": "wait for condition variable"}], "ExtractScale(mtx)": [{"body": "ExtractScale(${1:mtx})", "prefix": "ExtractScale(mtx)", "description": "Extract the absolute values of the scale component..."}], "GetMouse(context, index)": [{"body": "GetMouse(${1:context}, ${2:index})", "prefix": "GetMouse(context, index)", "description": "gets a mouse handle"}], "AcquireInstanceIndex(collection)": [{"body": "AcquireInstanceIndex(${1:collection})", "prefix": "AcquireInstanceIndex(collection)", "description": "Retrieve an instance index from the index pool for..."}], "dmScript::PushVector3(L, v)": [{"body": "dmScript::PushVector3(${1:L}, ${2:v})", "prefix": "dmScript::PushVector3(L, v)", "description": "push a Vectormath::Aos::Vector3 onto the Lua stack"}], "SetPath(url, path)": [{"body": "SetPath(${1:url}, ${2:path})", "prefix": "SetPath(url, path)", "description": "Set the message path"}], "dmMutex::Unlock(mutex)": [{"body": "dmMutex::Unlock(${1:mutex})", "prefix": "dmMutex::Unlock(mutex)", "description": "unlock Mutex."}], "dmHID::HKeyboard": [{"body": "dmHID::HKeyboard", "prefix": "dmHID::HKeyboard", "description": "keyboard context handle"}], "GetComponentFromLua(L, index, component_type, world, component, url)": [{"body": "GetComponentFromLua(${1:L}, ${2:index}, ${3:component_type}, ${4:world}, ${5:component}, ${6:url})", "prefix": "GetComponentFromLua(L, index, component_type, world, component, url)", "description": "Get component user data from a url"}], "dmThread::Detach(thread)": [{"body": "dmThread::Detach(${1:thread})", "prefix": "dmThread::Detach(thread)", "description": "detach thread"}], "dmSSLSocket::INVALID_SOCKET_HANDLE": [{"body": "dmSSLSocket::INVALID_SOCKET_HANDLE", "prefix": "dmSSLSocket::INVALID_SOCKET_HANDLE", "description": "SSLSocket socket handle"}], "dmSSLSocket::Delete(socket)": [{"body": "dmSSLSocket::Delete(${1:socket})", "prefix": "dmSSLSocket::Delete(socket)", "description": "delete a secure socket"}], "SetSize(size)": [{"body": "SetSize(${1:size})", "prefix": "SetSize(size)", "description": "array set size"}], "dmScript::CheckVector3(L, index)": [{"body": "dmScript::CheckVector3(${1:L}, ${2:index})", "prefix": "dmScript::CheckVector3(L, index)", "description": "check if the value is a Vectormath::Aos::Vector3"}], "Abs([type:class)": [{"body": "Abs(${1:[type:class})", "prefix": "Abs([type:class)", "description": "Abs function"}], "ResolvePointers(desc, message)": [{"body": "ResolvePointers(${1:desc}, ${2:message})", "prefix": "ResolvePointers(desc, message)", "description": "If the message was loaded with the flag dmDDF::OPT..."}], "dmConfigFile::HConfig": [{"body": "dmConfigFile::HConfig", "prefix": "dmConfigFile::HConfig", "description": "HConfig type definition"}], "Node": [{"body": "Node", "prefix": "Node", "description": "Json node representation."}], "HProgram": [{"body": "HProgram", "prefix": "HProgram", "description": "Program handle"}], "dmScript::PushBuffer(L, buffer)": [{"body": "dmScript::PushBuffer(${1:L}, ${2:buffer})", "prefix": "dmScript::PushBuffer(L, buffer)", "description": "push a LuaHBuffer onto the supplied lua state"}], "GetHostByName(name, address, timeout, cancelflag, ipv4, ipv6)": [{"body": "GetHostByName(${1:name}, ${2:address}, ${3:timeout}, ${4:cancelflag}, ${5:ipv4}, ${6:ipv6})", "prefix": "GetHostByName(name, address, timeout, cancelflag, ipv4, ipv6)", "description": "get host by name with timeout and cancelability"}], "dmScript::TeardownCallback(cbk)": [{"body": "dmScript::TeardownCallback(${1:cbk})", "prefix": "dmScript::TeardownCallback(cbk)", "description": "Cleans up the stack after SetupCallback+PCall calls"}], "RemoveHandler(server, prefix)": [{"body": "RemoveHandler(${1:server}, ${2:prefix})", "prefix": "RemoveHandler(server, prefix)", "description": "Remove handle"}], "AssignInstanceIndex(index, instance)": [{"body": "AssignInstanceIndex(${1:index}, ${2:instance})", "prefix": "AssignInstanceIndex(index, instance)", "description": "Assign an index to the instance, only if the insta..."}], "Apply(t, p)": [{"body": "Apply(${1:t}, ${2:p})", "prefix": "Apply(t, p)", "description": "Apply the transform on a point (includes the trans..."}], "dmScript::CheckHashOrString(L, index)": [{"body": "dmScript::CheckHashOrString(${1:L}, ${2:index})", "prefix": "dmScript::CheckHashOrString(L, index)", "description": "get hash from hash or string"}], "GetScale": [{"body": "GetScale()", "prefix": "GetScale", "description": "get scale"}], "dmMutex::Lock(mutex)": [{"body": "dmMutex::Lock(${1:mutex})", "prefix": "dmMutex::Lock(mutex)", "description": "lock Mutex."}], "Domain": [{"body": "Domain", "prefix": "Domain", "description": "domain type"}], "Send(request, data, data_length)": [{"body": "Send(${1:request}, ${2:data}, ${3:data_length})", "prefix": "Send(request, data, data_length)", "description": "Send response data"}], "dmScript::IsQuat(L, index)": [{"body": "dmScript::IsQuat(${1:L}, ${2:index})", "prefix": "dmScript::IsQuat(L, index)", "description": "Check if the value at #index is a Vectormath::Aos:..."}], "dmBuffer::GetSizeForValueType(type)": [{"body": "dmBuffer::GetSizeForValueType(${1:type})", "prefix": "dmBuffer::GetSizeForValueType(type)", "description": "get size of a value type"}], "ToMatrix(t)": [{"body": "ToMatrix(${1:t})", "prefix": "ToMatrix(t)", "description": "Convert a transform into a 4-dim matrix"}], "dmArray": [{"body": "dmArray", "prefix": "dmArray", "description": "Templatized array with bounds checking."}, {"body": "dmArray()", "prefix": "dmArray", "description": "constructor. empty auto-allocated memory"}], "Message": [{"body": "Message", "prefix": "Message", "description": ""}, {"body": "Message", "prefix": "Message", "description": "Message data desc used at dispatch callback. When ..."}], "dmHID::MAX_GAMEPAD_BUTTON_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_GAMEPAD_BUTTON_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_GAMEPAD_BUTTON_COUNT [type: uint32_t]", "description": "Maximum number of gamepad buttons supported"}], "dmSpinlock::Lock(spinlock)": [{"body": "dmSpinlock::Lock(${1:spinlock})", "prefix": "dmSpinlock::Lock(spinlock)", "description": "lock spinlock."}], "SetIndexBufferSubData(buffer, offset, size, data)": [{"body": "SetIndexBufferSubData(${1:buffer}, ${2:offset}, ${3:size}, ${4:data})", "prefix": "SetIndexBufferSubData(buffer, offset, size, data)", "description": "Set subset of index buffer data"}], "NewVertexDeclaration(context, element, count, stride)": [{"body": "NewVertexDeclaration(${1:context}, ${2:element}, ${3:count}, ${4:stride})", "prefix": "NewVertexDeclaration(context, element, count, stride)", "description": "Create new vertex declaration"}], "dmExtension::Result": [{"body": "dmExtension::Result", "prefix": "dmExtension::Result", "description": "result enumeration"}], "dmThread::SetTlsValue(key, value)": [{"body": "dmThread::SetTlsValue(${1:key}, ${2:value})", "prefix": "dmThread::SetTlsValue(key, value)", "description": "set thread specific data"}], "Playback": [{"body": "Playback", "prefix": "Playback", "description": "Playback type enum"}], "HHullSet2D": [{"body": "HHullSet2D", "prefix": "HHullSet2D", "description": "2D Hull set handle"}], "GetPosition(instance)": [{"body": "GetPosition(${1:instance})", "prefix": "GetPosition(instance)", "description": "get position"}], "dmURI::Decode(src, dst)": [{"body": "dmURI::Decode(${1:src}, ${2:dst})", "prefix": "dmURI::Decode(src, dst)", "description": "Decodes an URL encoded buffer"}], "NewNamedConstantBuffer": [{"body": "NewNamedConstantBuffer()", "prefix": "NewNamedConstantBuffer", "description": "Allocates a named constant buffer"}], "dmConnectionPool::New(params, pool)": [{"body": "dmConnectionPool::New(${1:params}, ${2:pool})", "prefix": "dmConnectionPool::New(params, pool)", "description": "Create a new connection pool"}], "dmCrypt::HashSha256(buf, buflen, digest)": [{"body": "dmCrypt::HashSha256(${1:buf}, ${2:buflen}, ${3:digest})", "prefix": "dmCrypt::HashSha256(buf, buflen, digest)", "description": "Hash buffer using SHA256"}], "dmGraphics::GetNativeOSXNSView": [{"body": "dmGraphics::GetNativeOSXNSView()", "prefix": "dmGraphics::GetNativeOSXNSView", "description": "get OSX NSView"}], "RenderListSubmit(context, begin, end)": [{"body": "RenderListSubmit(${1:context}, ${2:begin}, ${3:end})", "prefix": "RenderListSubmit(context, begin, end)", "description": "Adds a render object to the current render frame"}], "dmStrlCat(dst, src, size)": [{"body": "dmStrlCat(${1:dst}, ${2:src}, ${3:size})", "prefix": "dmStrlCat(dst, src, size)", "description": "Size-bounded string concatenation."}], "OPTION_OFFSET_POINTERS": [{"body": "OPTION_OFFSET_POINTERS()", "prefix": "OPTION_OFFSET_POINTERS", "description": "Store pointers as offset from base address. Needed..."}], "DeleteConstant(constant)": [{"body": "DeleteConstant(${1:constant})", "prefix": "DeleteConstant(constant)", "description": "Deletes a shader program constant"}], "dmScript::CreateCallback(L, index)": [{"body": "dmScript::CreateCallback(${1:L}, ${2:index})", "prefix": "dmScript::CreateCallback(L, index)", "description": "Register a Lua callback."}], "HVertexDeclaration": [{"body": "HVertexDeclaration", "prefix": "HVertexDeclaration", "description": "Vertex declaration handle"}], "dmGraphics::GetNativeOSXNSWindow": [{"body": "dmGraphics::GetNativeOSXNSWindow()", "prefix": "dmGraphics::GetNativeOSXNSWindow", "description": "get OSX NSWindow"}], "ResetScale(mtx)": [{"body": "ResetScale(${1:mtx})", "prefix": "ResetScale(mtx)", "description": "Eliminate the scaling components in a matrix"}], "dmHID::MAX_GAMEPAD_COUNT [type: uint32_t]": [{"body": "dmHID::MAX_GAMEPAD_COUNT [type: uint32_t]()", "prefix": "dmHID::MAX_GAMEPAD_COUNT [type: uint32_t]", "description": "Maximum number of gamepads supported"}], "dmHashReverseSafe64(hash, length)": [{"body": "dmHashReverseSafe64(${1:hash}, ${2:length})", "prefix": "dmHashReverseSafe64(hash, length)", "description": "get string value from hash"}], "dmGraphics::GetNativeX11Window": [{"body": "dmGraphics::GetNativeX11Window()", "prefix": "dmGraphics::GetNativeX11Window", "description": "get Linux X11Window"}], "dmScript::PCall(L, nargs, nresult)": [{"body": "dmScript::PCall(${1:L}, ${2:nargs}, ${3:nresult})", "prefix": "dmScript::PCall(L, nargs, nresult)", "description": "This function wraps lua_pcall with the addition of..."}], "HandlerParams": [{"body": "HandlerParams", "prefix": "HandlerParams", "description": "handler parameters"}], "Parse(buffer, document)": [{"body": "Parse(${1:buffer}, ${2:document})", "prefix": "Parse(buffer, document)", "description": "parse null terminated json data"}], "Mul(lhs, rhs)": [{"body": "Mul(${1:lhs}, ${2:rhs})", "prefix": "Mul(lhs, rhs)", "description": "Transforms the right-hand transform by the left-ha..."}], "SceneNodePropertyIterator": [{"body": "SceneNodePropertyIterator", "prefix": "SceneNodePropertyIterator", "description": "scene traversal node property"}], "SetIdentity": [{"body": "SetIdentity()", "prefix": "SetIdentity", "description": "initialize to identity transform"}], "DM_PLATFORM_OSX": [{"body": "DM_PLATFORM_OSX", "prefix": "DM_PLATFORM_OSX", "description": "Set if the platform is OSX "}], "AddKeyboardChar(keyboard, chr)": [{"body": "AddKeyboardChar(${1:keyboard}, ${2:chr})", "prefix": "AddKeyboardChar(keyboard, chr)", "description": "Add text input"}], "ComponentTypeSetOnInputFn(type, fn)": [{"body": "ComponentTypeSetOnInputFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetOnInputFn(type, fn)", "description": "set the component on-input callback"}], "dmScript::ToMatrix4(L, index)": [{"body": "dmScript::ToMatrix4(${1:L}, ${2:index})", "prefix": "dmScript::ToMatrix4(L, index)", "description": "get the value at index as a Vectormath::Aos::Matrix4*"}], "HIndexBuffer": [{"body": "HIndexBuffer", "prefix": "HIndexBuffer", "description": "Index buffer handle"}], "Parse(buffer, length, document)": [{"body": "Parse(${1:buffer}, ${2:length}, ${3:document})", "prefix": "Parse(buffer, length, document)", "description": "parse json data"}], "~dmArray": [{"body": "~dmArray()", "prefix": "~dmArray", "description": "array destructor"}], "ComponentTypeSetUpdateFn(type, fn)": [{"body": "ComponentTypeSetUpdateFn(${1:type}, ${2:fn})", "prefix": "ComponentTypeSetUpdateFn(type, fn)", "description": "set the component update callback"}], "RegisterOnActivityCreateListener([type:dmAndroid::OnActivityCreate])": [{"body": "RegisterOnActivityCreateListener(${1:[type:dmAndroid::OnActivityCreate]})", "prefix": "RegisterOnActivityCreateListener([type:dmAndroid::OnActivityCreate])", "description": "register Android onCreate callback"}], "IsSocketValid(socket)": [{"body": "IsSocketValid(${1:socket})", "prefix": "IsSocketValid(socket)", "description": "Tests if a socket is valid (not deleted)."}], "dmURI::Result": [{"body": "dmURI::Result()", "prefix": "dmURI::Result", "description": "URI parsing result"}], "dmHashFinal32(hash_state)": [{"body": "dmHashFinal32(${1:hash_state})", "prefix": "dmHashFinal32(hash_state)", "description": "Finalize incremental hashing and release associate..."}], "dmConditionVariable::Signal(condition)": [{"body": "dmConditionVariable::Signal(${1:condition})", "prefix": "dmConditionVariable::Signal(condition)", "description": "signal condition variable"}], "GetGameObjectRegister(app_params)": [{"body": "GetGameObjectRegister(${1:app_params})", "prefix": "GetGameObjectRegister(app_params)", "description": "get the game object register"}], "SetVertexBufferData(buffer, size, data, buffer_usage)": [{"body": "SetVertexBufferData(${1:buffer}, ${2:size}, ${3:data}, ${4:buffer_usage})", "prefix": "SetVertexBufferData(buffer, size, data, buffer_usage)", "description": "Set vertex buffer data"}], "Begin": [{"body": "Begin()", "prefix": "Begin", "description": "array begin"}], "dmGraphics::GetNativeAndroidEGLContext": [{"body": "dmGraphics::GetNativeAndroidEGLContext()", "prefix": "dmGraphics::GetNativeAndroidEGLContext", "description": "get Android EGLContext"}], "MulNoScaleZ(m1, m2)": [{"body": "MulNoScaleZ(${1:m1}, ${2:m2})", "prefix": "MulNoScaleZ(m1, m2)", "description": "Multiply two matrices without z-scaling the transl..."}], "TraverseIterateNext(it)": [{"body": "TraverseIterateNext(${1:it})", "prefix": "TraverseIterateNext(it)", "description": "Step a scene node iterator to the next sibling"}], "dmScript::DestroyCallback(cbk)": [{"body": "dmScript::DestroyCallback(${1:cbk})", "prefix": "dmScript::DestroyCallback(cbk)", "description": "Deletes the Lua callback"}], "HVertexBuffer": [{"body": "HVertexBuffer", "prefix": "HVertexBuffer", "description": "Vertex buffer handle"}], "RegisterOnActivityResultListener([type:dmAndroid::OnActivityResult])": [{"body": "RegisterOnActivityResultListener(${1:[type:dmAndroid::OnActivityResult]})", "prefix": "RegisterOnActivityResultListener([type:dmAndroid::OnActivityResult])", "description": "register Android activity result callback"}], "Map(fn, ctx)": [{"body": "Map(${1:fn}, ${2:ctx})", "prefix": "Map(fn, ctx)", "description": "map a function on all values"}], "GetWorldPosition(instance)": [{"body": "GetWorldPosition(${1:instance})", "prefix": "GetWorldPosition(instance)", "description": "get world position"}], "SelectorIsSet(selector, selector_kind, socket)": [{"body": "SelectorIsSet(${1:selector}, ${2:selector_kind}, ${3:socket})", "prefix": "SelectorIsSet(selector, selector_kind, socket)", "description": "Check if selector is set. Similar to FD_ISSET"}], "HPool": [{"body": "HPool", "prefix": "HPool", "description": "Connection pool handle"}], "Phase": [{"body": "Phase", "prefix": "Phase", "description": "touch phase enumeration"}], "dmSpinlock::Spinlock": [{"body": "dmSpinlock::Spinlock", "prefix": "dmSpinlock::Spinlock", "description": "Spinlock type definition"}], "RefInInstance(L, url, out_url, default_url)": [{"body": "RefInInstance(${1:L}, ${2:url}, ${3:out_url}, ${4:default_url})", "prefix": "RefInInstance(L, url, out_url, default_url)", "description": "Resolves a url in string format into a dmMessage::..."}], "dmScript::CheckBufferNoError(L, index)": [{"body": "dmScript::CheckBufferNoError(${1:L}, ${2:index})", "prefix": "dmScript::CheckBufferNoError(L, index)", "description": "retrieve a HBuffer from the supplied lua state."}], "DM_DEBUG": [{"body": "DM_DEBUG", "prefix": "DM_DEBUG", "description": "define for debug builds"}], "MulNoScaleZ(lhs, rhs)": [{"body": "MulNoScaleZ(${1:lhs}, ${2:rhs})", "prefix": "MulNoScaleZ(lhs, rhs)", "description": "Transforms the right-hand transform by the left-ha..."}], "dmExtension::Params": [{"body": "dmExtension::Params", "prefix": "dmExtension::Params", "description": "extension level callback data"}], "GetGamePad(context, index)": [{"body": "GetGamePad(${1:context}, ${2:index})", "prefix": "GetGamePad(context, index)", "description": "gets a gamepad device handle"}], "SetSocket(url, socket)": [{"body": "SetSocket(${1:url}, ${2:socket})", "prefix": "SetSocket(url, socket)", "description": "Set the socket"}], "PropertyValueType": [{"body": "PropertyValueType", "prefix": "PropertyValueType", "description": "Type of property value"}], "PropertyOptions": [{"body": "PropertyOptions", "prefix": "PropertyOptions", "description": "Property Options"}], "Receive(request, buffer, buffer_size, received_bytes)": [{"body": "Receive(${1:request}, ${2:buffer}, ${3:buffer_size}, ${4:received_bytes})", "prefix": "Receive(request, buffer, buffer_size, received_bytes)", "description": "Receive data"}], "SetUniformScale(scale)": [{"body": "SetUniformScale(${1:scale})", "prefix": "SetUniformScale(scale)", "description": "set uniform scale"}], "dmHashBuffer64(buffer, buffer_len)": [{"body": "dmHashBuffer64(${1:buffer}, ${2:buffer_len})", "prefix": "dmHashBuffer64(buffer, buffer_len)", "description": "calculate 64-bit hash value from buffer"}], "INVALID_SOCKET_HANDLE": [{"body": "INVALID_SOCKET_HANDLE", "prefix": "INVALID_SOCKET_HANDLE", "description": "Invalid socket handle"}]}